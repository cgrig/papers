\documentclass[conference,compsoc]{IEEEtran} % <<<
\usepackage[cmex10]{amsmath}\interdisplaylinepenalty=2500
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[nocompress]{cite}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}

\lstset{columns=fullflexible}
\lstset{identifierstyle=\itshape,commentstyle=\rm}
\lstdefinestyle{hs}{language=haskell,deletekeywords={elem,all,Eq}}
\lstdefinestyle{me}{language=haskell,keywords={role}}

% Format notes for [conference,compsoc]
%  - do NOT use \paragraph
%  - for figures, use \centering and put captions after
%  - refer to figures with "Figure", not "Fig" (you can use \figurename)
%  - put algorithms in figures, not other floats
%  - for tables, the caption comes *before*
%  - \section*{Acknowledgment}


\title{Roles and Modules}
\IEEEspecialpapernotice{(Position Paper)}
\author{
  \IEEEauthorblockN{Rem Collier and Claudia Grigore} 
  \IEEEauthorblockA{
    School of Computer Science and Informatics\\
    University College Dublin\\
    Belfield Campus, Dublin~4, Ireland\\
    Email: rem.collier@ucd.ie, claudia.grigore@ucdconnect.ie}}

% >>>
\begin{document} % <<<
\maketitle

\begin{abstract} % <<<

In Agent-Oriented Programming (AOP), roles and organisational structures
are regarded as important concepts in the analysis and design of agent
systems, but there is a significant lack of support for the implementation
stage of the development process. In response to this, a number of
organisational frameworks have emerged as powerful approaches to
implementing organisations. However, in our mind, this complicates rather
than simplifies the implementation: developers must understand and work
with both the organisational framework and the AOP language. In this paper,
we present an approach that introduces a general notion of a role for AOP
languages, the purpose of which is to reduce the gap between design and
implementation, and to offer run-time support for enforcing role
compliance. Our approach, which is inspired by Haskell's type classes,
cannot be conveniently implemented using existing AOP language concepts,
such as modules. Conversely, modules cannot be conveniently implemented
with (even our more general) roles. The two concepts are both useful in
organising large agent systems.  

\end{abstract} % >>>

\section{Introduction} % <<<

\todo{the gap between design and implementation of roles; we try to implement roles internal to agents}

\begin{notes}
AO is an evolution of OO that draws from social theory. In this paper we
illustrate how another analogy, with functional languages, helps advance 
AO\null. 

Organisations are increasingly seen as an important concept in agent
oriented design. However, little work has been done on applying
organisational concepts, like the one of role, to AOP languages. The main
approach to implementing organisations in multi agent systems are
organisational centered methodologies (OCM). They introduce an
organisational level built on top of the agent level. An organization is
seen as a kind of dynamic framework where agents are components, and
entering a group or playing a role may be seen as a plug-in process where a
component is integrated into a framework. Well known examples of such
methodologies are Moise+~\cite{DBLP:conf/atal/HubnerSB05} implemented in
S-Moise+~\cite{DBLP:conf/atal/HubnerSB05},
AGR~\cite{DBLP:conf/aose/FerberGM03} implemented in
MadKit~\cite{DBLP:conf/agents/GutknechtF00a}, and
Gaia~\cite{DBLP:journals/tosem/ZambonelliJW03} implemented with
JADE~\cite{DBLP:conf/jit/MoraitisPS02}.

Unfortunately the OCM's approach proves cumbersome, complicating rather
than simplifying the implementation of multi agent systems, because
developers must understand and work with both the organisational framework
and AOP language.

\end{notes}

% >>>
\section{Background} % <<<

\todo{Rem suggested to: -- think about the flow of the paper, maybe switching the 2.2 with 2.3; -- link roles and organisations}

We assume the reader is familiar with Java and with some agent-oriented
programming language, not necessarily 2APL. We do \emph{not} assume that
the reader is familiar with Haskell.

% >>>
\subsection{Modules in 2APL} % <<<

In Extended 2APL, agents are module
instances~\cite{DBLP:conf/prima/DastaniMS08}. At startup, the agent
interpreter creates a set of agents; later, agents may create other agents.
When an agent is created it is given a name, which can be used later to
refer to the agent. At this point, an informal analogy with Java may aid
the reader's intuition. Modules in 2APL are like classes in Java. The 2APL
action $\mathit{create}(A,x)$ placed in module~$B$ is analogous to the Java
statement $x=\mathbf{new}\,A$ placed in class~$B$ that has field~$x$.  The
analogy breaks quickly, however. For example, in 2APL it is a fault to
execute $\mathit{create}(A,x)$ twice without executing
$\mathit{release}(x)$ in-between. Hence, the number of co-existing agents
created by an instance of~$B$ is bounded by the number of distinct agent
names that appear in~$B$'s program text. (Note, however, that the total
number of agents is \emph{not} bounded, because an instance of~$A$ may
create an instance of~$B$ which creates an instance of~$A$ which creates an
instance of~$B$ and so on.)

Once an agent is created, its belief base may be queried and updated by the
agent's creator (given the proper access modifier).

Agents do \emph{not} start executing when they are instantiated. Agent~$x$
is executed synchronously by the action $x.\mathit{execute}(t)$ and
asynchronously by the action $x.\mathit{executeasync}(t)$. Coming back to
our Java analogy, these actions are like the statement
$e.\mathit{execute}(x)$, where $e$~is an instance of
$\mathit{java}.\mathit{util}.\mathit{concurrent}.\mathit{Executor}$ and
$x$~is an instance of $\mathit{java}.\mathit{lang}.\mathit{Runnable}$.  In
Java, depending on the executor, a new thread may be created or not; in
2APL, the agent is run asynchronously or not depending on which of
\textit{execute} and \textit{executeasync} is used. But again, the analogy
soon breaks. The test~$t$ has no counterpart in Java. In 2APL, when
$t$~holds, $x$~stops executing.

Other aspects of 2APL modules, such as how they interact with goals and
events, do not affect the current discussion.

% >>>
\subsection{Modules and Type Classes in Haskell} % <<<

% modules
%  - small example
%  - information hiding and encapsulation
%    (exact impl may change; but it is ONE)
%  - separate compilation
%  - analogy with Java classes

Haskell modules are often used to implement abstract data types such as
sets.  To illustrate the main features of modules in little space, the code
in Figure~\ref{fig:haskell} is contrived.  The module \textit{Set} contains
the type~$T$ and the functions \textit{add}, \textit{has}, and
\textit{sub}. The \textbf{module} line hides \textit{sub} by not mentioning
it. The names and types of the exported functions \textit{add} and
\textit{has} are visible from outside the module, but their
implementations, which are to the right of~$=$, are hidden.  Similarly, the
type name~$T$ is visible from outside, but the value constructor~$V$ is
not. For example, the set $\{1,2\}$ may be represented by the value
$V[2,1,2]$, but this is not known to the users of the module \textit{Set}.
The names and types visible from outside constitute the module's
\emph{interface}.

\begin{figure}\footnotesize % <<<
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=hs]
-- built-in and standard library
class Eq b where
  eq :: b -> b -> Bool
instance Eq Int where ...
elem x [] = False
elem x (y:ys) = eq x y || elem x ys
all p [] = True
all p (x:xs) = p x && all p xs

-- file set.hs
module Set (T, add, has) where
  newtype T a = V [a]
  add (V s) x = V (x:s)
  has (V s) x = elem x s
  sub (V s) t = all (has t) s

  instance Eq a => Eq (T a) where
    eq s t = sub s t && sub t s
\end{lstlisting}
\end{tabular}
\end{center}
\caption{Haskell type class \textit{Eq} and module \textit{Set}}
\label{fig:haskell}
\end{figure} % >>>

In general, modules are responsible with information hiding and
encapsulation. Well known advantages come from modularity. For humans,
modular programs are easier to write and to maintain. They are easier to
write because, to a certain degree, it is enough to understand the
interface of a module in order to use it. They are easier to maintain
because changes to a module's implementation remain local as long as the
interface is not affected. For compilers, modular programs enable separate
compilation. Thus, modules are an important device in structuring large
programs. \todo{Perhaps cite some early paper on modularity.}

Haskell modules are similar, from a very high distance, to Java classes.  A
Java class hides private parts and introduces \emph{one} type at the same
time. A Haskell module may introduce zero, one, or more types.  But many
Haskell modules do indeed export \emph{one} main type. 

% type classes
%  - continue example
%  - ad-hoc polymorphism: multiple implementations with the same interface
%  - analogy with Java interfaces

The type class \textit{Eq} contains types whose values can be compared for
equality. To make a type belong to the class \textit{Eq} one must write an
instance declaration that provides an implementation for a function
named~$eq$. \todo{Should we say that we lie here a little so that we don't
confuse people who don't know Haskell?} The \textbf{instance} declaration
in module \textit{Set} says that the type constructor~$T$ transforms
members of \textit{Eq} into members of \textit{Eq}. For example, sets of
sets of integers are members of \textit{Eq}, because \textit{Int} is a
member of \textit{Eq}. Here is \emph{part} of an evaluation of the
comparison between $V[V[1]]$ and $V[V[1,1]]$, both of which
represent~$\{\{1\}\}$.
\begin{align*}
&\phantom{\;\leadsto\;}
  \mathit{eq}\;V[V[1]]\;V[V[1,1]] \\
&\leadsto
  \mathit{sub}\;V[V[1]]\;V[V[1,1]]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[V[1,1]])\;[V[1]]\\
&\leadsto
  \mathit{has}\;V[V[1,1]]\;V[1]\\
&\leadsto
  \mathit{elem}\;V[1]\;[V[1,1]]\\
&\leadsto
  \mathit{eq}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{sub}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[1,1])\;[1]\\
&\leadsto
  \mathit{has}\;V[1,1]\;1 \\
&\leadsto
  \mathit{elem}\;1\;[1,1]\\
&\leadsto
  \mathit{eq}\;1\;1\\
&\leadsto
  \mathit{True}
\end{align*}
Notice, in particular, that \textit{eq} is applied on $T(T\,\mathit{Int})$,
then on $T\,\mathit{Int}$, and then on \textit{Int}.

In general, type classes are an elegant mechanism to provide ad-hoc
polymorphism, also known as overloading~\cite{DBLP:conf/popl/WadlerB89}:
The same name refers to different implementations depending on the context.
Type classes are similar to Java interfaces but there are several key
differences~\cite{WEB:PJ-tc}. For example, in Haskell it is easy to declare
a type from one library to be an instance of a class from another library.

% >>> >>>
\section{Connections} % <<<

Haskell and 2APL are very different languages. We do not aim to establish
any sort of formal connection between them, but rather to identify fruitful
high-level similarities. The task is akin trying to draw the Earth's
surface on paper---much easier to do locally than globally. We proceed,
therefore, by finding a contact point, seeing what it tells about its
surroundings, and then repeating.

\subsection{Functions as Sessions} % <<<

A function call $f\,x$ is evaluated by sending~$x$ to $f$'s body
($\beta$-reduction~\cite[Chapter~5]{DBLP:books/daglib/0005958}), evaluating
the body, and then receiving the result. The process is analogous to the
exchange of a pair of messages between two agents. Such an exchange of
messages is sometimes called a
\emph{session}~\cite{DBLP:conf/parle/TakeuchiHK94}. The function name~$f$
corresponds to a session identifier. The type of the argument corresponds
to a constraint on the content of the first message; the type of the result
corresponds to a constraint on the content of the reply message.

For example, the role \textit{Calculator} could be specified as follows.
\begin{lstlisting}[style=me]
role Num a => Calculator a
  eval :: Expr a -> a
\end{lstlisting}
An agent that plays the role $\mathit{Calculator}\,\mathit{Int}$ knows
how to compute expressions such as $(3+3)\times5$, given another agent
that plays the role $\mathit{Num}\,\mathit{Int}$.
\begin{lstlisting}[style=me]
role Num a
  add :: Pair a -> a
  multiply :: Pair a -> a
\end{lstlisting}
An agent that plays the role $\mathit{Num}\,\mathit{Int}$ knows how to
compute basic operations on integers, such as $3+3$ and $6\times5$. Given a
user agent~$u$, an agent~$c$ that plays
$\mathit{Calculator}\,\mathit{Int}$, and an agent~$n$ that plays
$\mathit{Num}\,\mathit{Int}$, the following is a possible exchange of
messages.
\begin{align*}
u\to c &: 
  \mathit{eval}(\mathit{call}(n),\mathit{Times}(
    \mathit{Plus}(\mathit{Ct}(3),\mathit{Ct}(3)),\mathit{Ct}(5)))\\
c\to n &: \mathit{add}(\mathit{call}(), \mathit{MkPair}(3, 3))\\
n\to c &: \mathit{add}(\mathit{return}(), 6)\\
c\to n &: \mathit{multiply}(\mathit{call}(), \mathit{MkPair}(6, 5))\\
n\to c &: \mathit{multiply}(\mathit{return}(), 30)\\
c\to u &: \mathit{eval}(\mathit{return}(), 30)
\end{align*}

Each function~$f$ that appears in a \textbf{role}~$r$ describes a pair of
messages, the call $f(\mathit{call}(a_1,\ldots,a_n),p)$ and the response
$f(\mathit{return}(),q)$. Here $a_1$, \dots,~$a_n$ are (addresses of) other
agents; $p$~is the value sent to an agent playing~$r$; and $q$~is return
value. The trick of sending $a_1$, \dots,~$\_n$ with every request message
is very similar to how type classes are implemented in Haskell
compilers~\cite{DBLP:journals/toplas/HallHJW96}.
Messages are terms in predicate logic. In particular,
\textit{return} is a constant (function with arity~0), and
$\mathit{call}(a_1,\ldots,a_n)$ is a notational shorthand for
$\mathit{call}(\mathit{cons}(a_1,\ldots,\mathit{cons}(a_n,\mathit{nil}())\ldots))$.
The function symbol \textit{MkPair} corresponds to the (unique) value
constructor of the type constructor \textit{Pair}.
\begin{lstlisting}[style=hs]
data Pair a = MkPair a a
\end{lstlisting}
\todo{The difference between \textbf{data} and \textbf{newtype} in Haskell
is not interesting for the story here, but readers will wonder. What to
do?} The function symbols \textit{Times}, \textit{Plus}, and \textit{Ct}
correspond to value constructors for expressions.
\begin{lstlisting}[style=hs]
data Expr a = Times a a | Plus a a | Ct a
\end{lstlisting}

\todo{Rewrite this. Goal: overview of connection in high-level terms. IOW,
summarize example.}
Notice that this way of defining roles is directly inspired by type
classes. Some implementation details, such as the \textit{initSession}
message are also very similar to how type classes are implemented in
Haskell compilers. More importantly, given this direct connection with type
classes, it should be possibly to check \emph{statically} that there will
be no type error at runtime. Of course, if the source of some agents in a
system is not checked, then they might still send messages that cause type
errors at runtime in the agents that were checked.

% >>>

\subsection{Types as Agents} % <<<

\todo{Talk about multiparty session types.}

% >>>
\todo{This is the last thing that we came up with: roles -- type classes, agents -- types, obligations -- functions, permissions -- data. We also considered the analogy between functions and: capabilities, protocols, activities. Consider modeling obligations with preconditions and postconditions.}

\begin{notes}
Idea: Find a clear argument of why Haskell type classes and modules are
orthogonal feature. Then find an analogy between (a part of) Haskell and (a
part of) 2APL that makes it possible to carry over the argument. Spend most
of the paper in this article on explaining the latter argument.

In general, modules are abstraction boundaries that help isolate
implementation details, and may also help compilers and interpreters to be
more efficient.  More importantly, modules help humans design and
understand large systems.

The \textit{create} action has no equivalent in Haskell. However, most
Haskell modules export \emph{one} main data type and functions to
instantiate it. For example, the module $\mathit{Data}.\mathit{Set}$
exports the type $\mathit{Set}\,a$ and the constant
$\mathit{empty}::\mathit{Set}\,a$.  We use this to extend the analogy: \[
\textit{2APL module} \sim \textit{Haskell module} \sim \textit{Haskell
type}. \]

Type classes are sets of types, all of which support similar operations.
The analogy would then be a set of 2APL modules, all of which support
similar operations. Except there's no notion of ``operation'' so we must
find a suitable analogue.

A function of type $s\to t$ takes an object of type $s$ and returns one of
type~$t$. The analogy now cracks a bit: Haskel's types were supposed to be
like 2APL modules (at least the types that are the ``main'' ones in some
module); however, something that takes modules and produces modules is more
like an OCaml functor, and putting that in a type-class sounds $\ldots$
complicated. The goal here is to be able to mix and match different modules
in certain context, just like type classes allow you to use different
implementations for fixed point addition and floating point addition
without sweating about it.

So, let's take a step backward: If not all Haskell types are ``main'' and
therefore analogue to 2APL modules, then what is their analogue? One
possibility is messages. So a function of type $s\to t$ is like a promise:
``If you give me message~$s$, I will (eventually) send you back a
message~$t$.'' Another possibility is beliefs: ``If now I believe~$s$,
(there's a good chance) I'll evolve to believe~$t$.''

\end{notes}

% >>>
\section{Example} % <<<

\begin{notes}
Ideally, a 2APL program that uses the proposed roles, and that is 
cumbersome to write using only modules or only roles.
\end{notes}

% >>>
\section{Other Languages} % <<<

\begin{notes}
Do roles make sense in other agent programming languages? Since AgentFactory
supports multiple agent programming languages, it provides a great setting
for exploring this question.
\end{notes}

% >>>
\section{Conclusion} % <<<

% >>>
% ending <<<
\section*{Acknowledgment}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,rm}

\section*{Notes}

Roles (like type classes) can have more than one implementation: Each agent
plays a role in its own way.

% >>>
\end{document} % >>>

% vim:tw=75:fmr=<<<,>>>:fo+=t:
