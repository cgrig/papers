\documentclass[conference,compsoc]{IEEEtran} % <<<
\usepackage[cmex10]{amsmath}\interdisplaylinepenalty=2500
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[nocompress]{cite}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}

\lstset{columns=fullflexible}
\lstset{identifierstyle=\itshape,commentstyle=\rm}
\lstdefinestyle{hs}{language=haskell,deletekeywords={elem,all,Eq}}
\lstdefinestyle{me}{language=haskell,keywords={role}}

% Format notes for [conference,compsoc]
%  - do NOT use \paragraph
%  - for figures, use \centering and put captions after
%  - refer to figures with "Figure", not "Fig" (you can use \figurename)
%  - put algorithms in figures, not other floats
%  - for tables, the caption comes *before*
%  - \section*{Acknowledgment}


\title{Roles and Modules}
\IEEEspecialpapernotice{(Position Paper)}
\author{
  \IEEEauthorblockN{Rem Collier and Claudia Grigore} 
  \IEEEauthorblockA{
    School of Computer Science and Informatics\\
    University College Dublin\\
    Belfield Campus, Dublin~4, Ireland\\
    Email: rem.collier@ucd.ie, claudia.grigore@ucdconnect.ie}}

% >>>
\begin{document} % <<<
\maketitle

\begin{abstract} % <<<

In Agent-Oriented Programming (AOP), roles and organisational structures
are regarded as important concepts in the analysis and design of agent
systems, but there is a significant lack of support for the implementation
stage of the development process. In response to this, a number of
organisational frameworks have emerged as powerful approaches to
implementing organisations. However, in our mind, this complicates rather
than simplifies the implementation: developers must understand and work
with both the organisational framework and the AOP language. In this paper,
we present an approach that introduces a general notion of a role for AOP
languages, the purpose of which is to reduce the gap between design and
implementation, and to offer run-time support for enforcing role
compliance. Our approach, which is inspired by Haskell's type classes,
cannot be conveniently implemented using existing AOP language concepts,
such as modules. Conversely, modules cannot be conveniently implemented
with (even our more general) roles. The two concepts are both useful in
organising large agent systems.  

\end{abstract} % >>>

\section{Introduction} % <<<

\todo{the gap between design and implementation of roles; we try to implement roles internal to agents}

\begin{notes}
AO is an evolution of OO that draws from social theory. In this paper we
illustrate how another analogy, with functional languages, helps advance 
AO\null. 

Organisations are increasingly seen as an important concept in agent
oriented design. However, little work has been done on applying
organisational concepts, like the one of role, to AOP languages. The main
approach to implementing organisations in multi agent systems are
organisational centered methodologies (OCM). They introduce an
organisational level built on top of the agent level. An organization is
seen as a kind of dynamic framework where agents are components, and
entering a group or playing a role may be seen as a plug-in process where a
component is integrated into a framework. Well known examples of such
methodologies are Moise+~\cite{DBLP:conf/atal/HubnerSB05} implemented in
S-Moise+~\cite{DBLP:conf/atal/HubnerSB05},
AGR~\cite{DBLP:conf/aose/FerberGM03} implemented in
MadKit~\cite{DBLP:conf/agents/GutknechtF00a}, and
Gaia~\cite{DBLP:journals/tosem/ZambonelliJW03} implemented with
JADE~\cite{DBLP:conf/jit/MoraitisPS02}.

Unfortunately the OCM's approach proves cumbersome, complicating rather
than simplifying the implementation of multi agent systems, because
developers must understand and work with both the organisational framework
and AOP language.

\end{notes}

% >>>
\section{Background} % <<<

\todo{Rem suggested to: -- think about the flow of the paper, maybe switching the 2.2 with 2.3; -- link roles and organisations}

We assume the reader is familiar with Java and with some agent-oriented
programming language, not necessarily
2APL~\cite{DBLP:journals/aamas/Dastani08}. We do \emph{not} assume that the
reader is familiar with Haskell.

\subsection{Modules in 2APL} % <<<

In Extended 2APL, agents are module
instances~\cite{DBLP:conf/prima/DastaniMS08}. At startup, the agent
interpreter creates a set of agents; later, agents may create other agents.
When an agent is created it is given a name, which can be used later to
refer to the agent. At this point, an informal analogy with Java may aid
the reader's intuition. Modules in 2APL are like classes in Java. The 2APL
action $\mathit{create}(A,x)$ placed in module~$B$ is analogous to the Java
statement $x=\mathbf{new}\,A$ placed in class~$B$ that has field~$x$.  The
analogy breaks quickly, however. For example, in 2APL it is a fault to
execute $\mathit{create}(A,x)$ twice without executing
$\mathit{release}(x)$ in-between. Hence, the number of co-existing agents
created by an instance of~$B$ is bounded by the number of distinct agent
names that appear in~$B$'s program text. (Note, however, that the total
number of agents is \emph{not} bounded, because an instance of~$A$ may
create an instance of~$B$ which creates an instance of~$A$ which creates an
instance of~$B$ and so on.)

Once an agent is created, its belief base may be queried and updated by the
agent's creator (given the proper access modifier).

Agents do \emph{not} start executing when they are instantiated. Agent~$x$
is executed synchronously by the action $x.\mathit{execute}(t)$ and
asynchronously by the action $x.\mathit{executeasync}(t)$. Coming back to
our Java analogy, these actions are like the statement
$e.\mathit{execute}(x)$, where $e$~is an instance of
$\mathit{java}.\mathit{util}.\mathit{concurrent}.\mathit{Executor}$ and
$x$~is an instance of $\mathit{java}.\mathit{lang}.\mathit{Runnable}$.  In
Java, depending on the executor, a new thread may be created or not; in
2APL, the agent is run asynchronously or not depending on which of
\textit{execute} and \textit{executeasync} is used. But again, the analogy
soon breaks. The test~$t$ has no counterpart in Java. In 2APL, when
$t$~holds, $x$~stops executing.

Other aspects of 2APL modules, such as how they interact with goals and
events, do not affect the current discussion.

% >>>
\subsection{Modules and Type Classes in Haskell} % <<<

% modules
%  - small example
%  - information hiding and encapsulation
%    (exact impl may change; but it is ONE)
%  - separate compilation
%  - analogy with Java classes

Haskell modules are often used to implement abstract data types such as
sets.  To illustrate the main features of modules in little space, the code
in Figure~\ref{fig:haskell} is contrived.  The module \textit{Set} contains
the type~$T$ and the functions \textit{add}, \textit{has}, and
\textit{sub}. The \textbf{module} line hides \textit{sub} by not mentioning
it. The names and types of the exported functions \textit{add} and
\textit{has} are visible from outside the module, but their
implementations, which are to the right of~$=$, are hidden.  Similarly, the
type name~$T$ is visible from outside, but the value constructor~$V$ is
not. For example, the set $\{1,2\}$ may be represented by the value
$V[2,1,2]$, but this is not known to the users of the module \textit{Set}.
The names and types visible from outside constitute the module's
\emph{interface}.

\begin{figure}\footnotesize % <<<
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=hs]
-- built-in and standard library
class Eq b where
  eq :: b -> b -> Bool
instance Eq Int where ...
elem x [] = False
elem x (y:ys) = eq x y || elem x ys
all p [] = True
all p (x:xs) = p x && all p xs

-- file set.hs
module Set (T, add, has) where
  data T a = V [a]
  add (V s) x = V (x:s)
  has (V s) x = elem x s
  sub (V s) t = all (has t) s

  instance Eq a => Eq (T a) where
    eq s t = sub s t && sub t s
\end{lstlisting}
\end{tabular}
\end{center}
\caption{Haskell type class \textit{Eq} and module \textit{Set}}
\label{fig:haskell}
\end{figure} % >>>

In general, modules are responsible with information hiding and
encapsulation. Well known advantages come from modularity. For humans,
modular programs are easier to write and to maintain. They are easier to
write because, to a certain degree, it is enough to understand the
interface of a module in order to use it. They are easier to maintain
because changes to a module's implementation remain local as long as the
interface is not affected. For compilers, modular programs enable separate
compilation. Thus, modules are an important device in structuring large
programs. \todo{Perhaps cite some early paper on modularity.}

Haskell modules are similar, from a very high distance, to Java classes.  A
Java class hides private parts and introduces \emph{one} type at the same
time. A Haskell module may introduce zero, one, or more types.  But many
Haskell modules do indeed export \emph{one} main type. 

% type classes
%  - continue example
%  - ad-hoc polymorphism: multiple implementations with the same interface
%  - analogy with Java interfaces

The type class \textit{Eq} contains types whose values can be compared for
equality. To make a type belong to the class \textit{Eq} one must write an
instance declaration that provides an implementation for a function
named~$eq$. \todo{Should we say that we lie here a little so that we don't
confuse people who don't know Haskell?} The \textbf{instance} declaration
in module \textit{Set} says that the type constructor~$T$ transforms
members of \textit{Eq} into members of \textit{Eq}. For example, sets of
sets of integers are members of \textit{Eq}, because \textit{Int} is a
member of \textit{Eq}. Here is \emph{part} of an evaluation of the
comparison between $V[V[1]]$ and $V[V[1,1]]$, both of which
represent~$\{\{1\}\}$.
\begin{align*}
&\phantom{\;\leadsto\;}
  \mathit{eq}\;V[V[1]]\;V[V[1,1]] \\
&\leadsto
  \mathit{sub}\;V[V[1]]\;V[V[1,1]]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[V[1,1]])\;[V[1]]\\
&\leadsto
  \mathit{has}\;V[V[1,1]]\;V[1]\\
&\leadsto
  \mathit{elem}\;V[1]\;[V[1,1]]\\
&\leadsto
  \mathit{eq}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{sub}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[1,1])\;[1]\\
&\leadsto
  \mathit{has}\;V[1,1]\;1 \\
&\leadsto
  \mathit{elem}\;1\;[1,1]\\
&\leadsto
  \mathit{eq}\;1\;1\\
&\leadsto
  \mathit{True}
\end{align*}
Notice, in particular, that \textit{eq} is applied on $T(T\,\mathit{Int})$,
then on $T\,\mathit{Int}$, and then on \textit{Int}.

In general, type classes are an elegant mechanism to provide ad-hoc
polymorphism, also known as overloading~\cite{DBLP:conf/popl/WadlerB89}:
The same name refers to different implementations depending on the context.
Type classes are similar to Java interfaces but there are several key
differences~\cite{WEB:PJ-tc}. For example, in Haskell it is easy to declare
a type from one library to be an instance of a class from another library.

% >>> >>>
\section{Connections} % <<<

Haskell and 2APL are very different languages. We do not aim to establish
any sort of formal connection between them, but rather to identify fruitful
high-level similarities. The task is akin trying to draw the Earth's
surface on paper---much easier to do locally than globally. We proceed,
therefore, by finding a contact point, seeing what it tells about its
surroundings, and then repeating.

\subsection{Functions as Messages} % <<<

A function call $f\,x$ is evaluated by `sending'~$x$ to $f$'s body,
evaluating the body, and then receiving the result. The process is
analogous to the exchange of a pair of messages between two agents. For
example, the role \textit{Calculator} could be specified as follows.
\begin{lstlisting}[style=me]
role Num a => Calculator a
  eval :: Expr a -> a
\end{lstlisting}
An agent that plays the role $\mathit{Calculator}\,\mathit{Int}$ knows
how to compute expressions such as $(3+3)\times5$, given another agent
that plays the role $\mathit{Num}\,\mathit{Int}$.
\begin{lstlisting}[style=me]
role Num a
  add :: Pair a -> a
  multiply :: Pair a -> a
\end{lstlisting}
An agent that plays the role $\mathit{Num}\,\mathit{Int}$ knows how to
compute basic operations on integers, such as $3+3$ and $6\times5$. The
types \textit{Expr} and \textit{Pair} constrain the content of messages.
\begin{lstlisting}[style=hs]
data Expr a = Times (Expr a) (Expr a) 
            | Plus (Expr a) (Expr a) 
            | Ct a
data Pair a = MkPair a a
\end{lstlisting}
Given a user agent~$u$, an agent~$c$ that plays
$\mathit{Calculator}\,\mathit{Int}$, and an agent~$n$ that plays
$\mathit{Num}\,\mathit{Int}$, the following is a possible exchange of
messages.
\begin{align*}
u\to c &: 
  \mathit{eval}(\mathit{call}(n),\\
  &\qquad\mathit{Times}(
    \mathit{Plus}(\mathit{Ct}(3),\mathit{Ct}(3)),\mathit{Ct}(5)))\\
c\to n &: \mathit{add}(\mathit{call}(), \mathit{MkPair}(3, 3))\\
n\to c &: \mathit{add}(\mathit{return}(), 6)\\
c\to n &: \mathit{multiply}(\mathit{call}(), \mathit{MkPair}(6, 5))\\
n\to c &: \mathit{multiply}(\mathit{return}(), 30)\\
c\to u &: \mathit{eval}(\mathit{return}(), 30)
\end{align*}

In general, $f::a\to b$ says that the agent understands messages of the
form $f(\mathit{call}(\alpha_1,\ldots,\alpha_n),x)$ and eventually replies
to each of them with a message of the form $f(\mathit{return}(),y)$. Here,
$\alpha_1$, \dots,~$\alpha_n$ are (addresses of) other agents, $x$~is a
value of type~$a$, and $y$~is a value of type~$b$.

The analogy so far is already fruitful. The content of 2APL messages is a
(ground) term or an atomic formula. Since 2APL is built on top
JADE~\cite{DBLP:books/sp/map2005/BellifemineBCP05}, the message content may
also be declared as part of an ontology. However, if we would show the JADE
ontology for arithmetic expressions we would run over the page limit by a
couple of pages. Contrast with the three short lines used here to define
$\mathit{Expr}\,a$. The definition is not only short and readable, but also
polymorphic in the type~$a$ of the constants, and rooted in the theory of
algebraic data types (see, for example, \cite{DBLP:conf/ctcs/Hagino87}).


It is unclear what is a good analogue for \textbf{instance} declarations,
but here is an attempt.

\todo{Analogue of \textbf{instance}---the implementation of roles.}

% >>>

\subsection{Types as Agents} % <<<

\todo{Talk about multiparty session types.}

% >>>

\todo{This is the last thing that we came up with: roles -- type classes,
agents -- types, obligations -- functions, permissions -- data. We also
considered the analogy between functions and: capabilities, protocols,
activities. Consider modeling obligations with preconditions and
postconditions.}


% >>>
\section{Example} % <<<

\begin{notes}
Ideally, a 2APL program that uses the proposed roles, and that is 
cumbersome to write using only modules or only roles.

Perhaps Map-Reduce, were the mappers have different implementations?
\end{notes}

% >>>
\section{Discussion} % <<<

The 


\begin{notes}
\begin{itemize}
\item How to implement roles?
\item What static checking is possible?
\item Connection to FIPA.
\end{itemize}

Do roles make sense in other agent programming languages? Since AgentFactory
supports multiple agent programming languages, it provides a great setting
for exploring this question.
\end{notes}

% >>>
\section{Conclusion} % <<<

% >>>
% ending <<<
\section*{Acknowledgment}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,rm}

\section*{Notes}

Roles (like type classes) can have more than one implementation: Each agent
plays a role in its own way.

% >>>
\end{document} % >>>

% vim:tw=75:fmr=<<<,>>>:fo+=t:
