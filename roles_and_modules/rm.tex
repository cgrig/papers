\documentclass[conference,compsoc]{IEEEtran} % <<<
\usepackage[cmex10]{amsmath}\interdisplaylinepenalty=2500
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[nocompress]{cite}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}

\lstset{columns=fullflexible}
\lstset{identifierstyle=\itshape,commentstyle=\rm}
\lstset{literate={->}{{$\to\;$}}1 {<-}{{$\gets\;$}}1 {=>}{{$\Rightarrow\;$}}1}
\lstdefinestyle{hs}{language=haskell,deletekeywords={elem,all,Eq,Num,Int}}
\lstdefinestyle{me}{language=haskell,keywords={role,agent,plays,true,this,PG,R,rules,send,session,repeat}}

% Format notes for [conference,compsoc]
%  - do NOT use \paragraph
%  - for figures, use \centering and put captions after
%  - refer to figures with "Figure", not "Fig" (you can use \figurename)
%  - put algorithms in figures, not other floats
%  - for tables, the caption comes *before*
%  - \section*{Acknowledgment}

\title{Supporting Agent Systems in the Programming Language}
\IEEEspecialpapernotice{(Position Paper)}
\author{
  \IEEEauthorblockN{Claudia Grigore and Rem Collier} 
  \IEEEauthorblockA{
    School of Computer Science and Informatics\\
    University College Dublin\\
    Belfield Campus, Dublin~4, Ireland\\
    Email: claudia.grigore@ucdconnect.ie, rem.collier@ucd.ie}}

% >>>
\begin{document} % <<<
\maketitle
\begin{abstract} % <<<

Methodologies for the design and development of agent-oriented programs
emphasize concepts, such as roles and organisations, that help structure
large agent systems. Several organisation frameworks support such concepts.
We believe, however, that these concepts should be supported directly by
the programming language, in order to be truly easy to use by developers.
In this paper we draw on an analogy between Haskell and 2APL and propose
three language features aimed at structuring large agent systems: algebraic
types, roles, and sessions. Each existed independently in some other
setting. We show how they fit in the context of an agent-oriented
programming language and how they fit with each other.

\end{abstract} % >>>
\section{Introduction} % <<<

Many developers ignore methodologies, but none can ignore the programming
language she uses. Thus, concepts with support in programming languages
have better chances of wide adoption compared to concepts that appear only
in methodologies. We feel that discussion of how to structure large agent
systems needs to change focus from methodologies to programming languages.
In this article, we illustrate the kind of issues on which we intend to
focus in the future, and in which we hope other researchers will become
more interested. By necessity, the style is informal---a precise solution
would require much more than four pages, even a precise solution for a
single issue out of those discussed.

The general approach is to get inspiration from analogies between
agent-oriented programming languages and functional languages. Analogies
are relatively common in the agents research community, but usually they
are made with theories in sociology. To avoid the temptation to be overly
abstract we decided in the beginning to stick to one particular
agent-oriented programming language,
2APL~\cite{DBLP:journals/aamas/Dastani08}, and one particular functional
programming language, Haskell~\cite{web:haskell}. We chose 2APL mainly
because it has formal syntax and semantics, and is therefore easy to
understand. Also, it was suggested that 2APL with modules does not need
roles~\cite{dblp:conf/prima/dastanims08}, a view we disagree with.

\todo{Continue here.}

% >>>
\section{Background} % <<<

We assume the reader is familiar with 2APL.

We assume the reader is familiar with Java and with some agent-oriented
programming language, not necessarily
2APL~\cite{DBLP:journals/aamas/Dastani08}. We do \emph{not} assume that the
reader is familiar with Haskell~\cite{web:haskell}. The reader who does
know Haskell will notice that we bend the truth in the interest of
simplicity.

% modules
%  - small example
%  - information hiding and encapsulation
%    (exact impl may change; but it is ONE)
%  - separate compilation
%  - analogy with Java classes

Haskell modules are often used to implement abstract data types such as
sets.  To illustrate the main features of modules in little space, the code
in Figure~\ref{fig:haskell} is contrived.  The module \textit{Set} contains
the type~$T$ and the functions \textit{add}, \textit{has}, and
\textit{sub}. The \textbf{module} line hides \textit{sub} by not mentioning
it. The names and types of the exported functions \textit{add} and
\textit{has} are visible from outside the module, but their
implementations, which are to the right of~$=$, are hidden.  Similarly, the
type name~$T$ is visible from outside, but the value constructor~$V$ is
not. For example, the set $\{1,2\}$ may be represented by the value
$V[2,1,2]$, but this is not known to the users of the module \textit{Set}.
The names and types visible from outside constitute the module's
\emph{interface}.

\begin{figure}\footnotesize % <<<
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=hs]
-- built-in and standard library
class Eq b where
  eq :: b -> b -> Bool
instance Eq Int where ...
elem x [] = False
elem x (y:ys) = eq x y || elem x ys
all p [] = True
all p (x:xs) = p x && all p xs

-- file set.hs
module Set (T, add, has) where
  data T a = V [a]
  add (V s) x = V (x:s)
  has (V s) x = elem x s
  sub (V s) t = all (has t) s

  instance Eq a => Eq (T a) where
    eq s t = sub s t && sub t s
\end{lstlisting}
\end{tabular}
\end{center}
\caption{Haskell type class \textit{Eq} and module \textit{Set}}
\label{fig:haskell}
\end{figure} % >>>

% type classes
%  - continue example
%  - ad-hoc polymorphism: multiple implementations with the same interface
%  - analogy with Java interfaces

The type class \textit{Eq} contains types whose values can be compared for
equality. To make a type belong to the class \textit{Eq} one must write an
instance declaration that provides an implementation for a function
named~$eq$. The \textbf{instance} declaration in module \textit{Set} says
that the type constructor~$T$ transforms members of \textit{Eq} into
members of \textit{Eq}. For example, $T(T\,\mathit{Int})$ is in \textit{Eq}
because \textit{Int} is in \textit{Eq.} Here is \emph{part} of an
evaluation of the comparison between $V[V[1]]$ and $V[V[1,1]]$, both of
which represent~$\{\{1\}\}$.
\begin{align*}
&\phantom{\;\leadsto\;}
  \mathit{eq}\;V[V[1]]\;V[V[1,1]] \\
&\leadsto
  \mathit{sub}\;V[V[1]]\;V[V[1,1]]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[V[1,1]])\;[V[1]]\\
&\leadsto
  \mathit{has}\;V[V[1,1]]\;V[1]\\
&\leadsto
  \mathit{elem}\;V[1]\;[V[1,1]]\\
&\leadsto
  \mathit{eq}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{sub}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[1,1])\;[1]\\
&\leadsto
  \mathit{has}\;V[1,1]\;1 \\
&\leadsto
  \mathit{elem}\;1\;[1,1]\\
&\leadsto
  \mathit{eq}\;1\;1\\
&\leadsto
  \mathit{True}
\end{align*}
Notice, in particular, that \textit{eq} is applied on $T(T\,\mathit{Int})$,
then on $T\,\mathit{Int}$, and then on \textit{Int}.

In general, modules are responsible with information
hiding~\cite{DBLP:journals/cacm/Parnas72a} and encapsulation. Well known
advantages come from modularity. For humans, modular programs are easier to
write and to maintain. They are easier to write because, to a certain
degree, it is enough to understand the interface of a module in order to
use it. They are easier to maintain because changes to a module's
implementation remain local as long as the interface is not affected. For
compilers, modular programs enable separate compilation. Thus, modules are
an important device in structuring large programs.

Haskell modules, like 2APL modules,  are somewhat similar to Java classes.
A Java class hides private parts and introduces \emph{one} type at the same
time. A Haskell module may introduce zero, one, or more types.  But many
Haskell modules do indeed export \emph{one} main type. 

On the other hand, type classes are an elegant mechanism to provide ad-hoc
polymorphism, also known as overloading~\cite{DBLP:conf/popl/WadlerB89}:
The same name refers to different implementations depending on the context.
Type classes are similar to Java interfaces but there are several key
differences~\cite{WEB:PJ-tc}. For example, in Haskell it is easy to declare
a type from one library to be an instance of a class from another library.

% >>>
\section{Connections} % <<<

Haskell and 2APL are very different languages. We do not aim to establish
any sort of formal connection between them, but rather to identify fruitful
high-level similarities. The task is akin trying to draw the Earth's
surface on paper---much easier to do locally than globally. We proceed,
therefore, by finding a contact point, seeing what it tells about its
surroundings, and then repeating.

\subsection{Functions as Messages} % <<<

A function call $f\,x$ is evaluated by `sending'~$x$ to $f$'s body,
evaluating the body, and then receiving the result. The process is
analogous to the exchange of a pair of messages between two agents. For
example, the role \textit{Calculator} could be specified as follows.
\begin{lstlisting}[style=me]
role Num a => Calculator a
  eval :: Expr a -> a
\end{lstlisting}
An agent that plays the role $\mathit{Calculator}\,\mathit{Int}$ knows
how to compute expressions such as $(3+3)\times5$, given another agent
that plays the role $\mathit{Num}\,\mathit{Int}$.
\begin{lstlisting}[style=me]
role Num a
  add :: Pair a -> a
  multiply :: Pair a -> a
\end{lstlisting}
An agent that plays the role $\mathit{Num}\,\mathit{Int}$ knows how to
compute basic operations on integers, such as $3+3$ and $6\times5$. The
types \textit{Expr} and \textit{Pair} constrain the content of messages.
\begin{lstlisting}[style=hs]
data Expr a = Times (Expr a) (Expr a) 
            | Plus (Expr a) (Expr a) 
            | Ct a
data Pair a = MkPair a a
\end{lstlisting}
Given a user agent~$u$, an agent~$c$ that plays
$\mathit{Calculator}\,\mathit{Int}$, and an agent~$n$ that plays
$\mathit{Num}\,\mathit{Int}$, the following is a possible exchange of
messages.
\begin{align*}
u\to c &: 
  \mathit{eval}(\mathit{call}(n),\\
  &\qquad\mathit{Times}(
    \mathit{Plus}(\mathit{Ct}(3),\mathit{Ct}(3)),\mathit{Ct}(5)))\\
c\to n &: \mathit{add}(\mathit{call}(), \mathit{MkPair}(3, 3))\\
n\to c &: \mathit{add}(\mathit{return}(), 6)\\
c\to n &: \mathit{multiply}(\mathit{call}(), \mathit{MkPair}(6, 5))\\
n\to c &: \mathit{multiply}(\mathit{return}(), 30)\\
c\to u &: \mathit{eval}(\mathit{return}(), 30)
\end{align*}

In general, $f::a\to b$ says that the agent understands messages of the
form $f(\mathit{call}(\alpha_1,\ldots,\alpha_n),x)$ and eventually replies
to each of them with a message of the form $f(\mathit{return}(),y)$. Here,
$\alpha_1$, \dots,~$\alpha_n$ are (addresses of) other agents, $x$~is a
value of type~$a$, and $y$~is a value of type~$b$.

The analogy so far is already fruitful. The content of 2APL messages is a
(ground) term or an atomic formula. Since 2APL is built on top
JADE~\cite{DBLP:books/sp/map2005/BellifemineBCP05}, the message content may
also be declared as part of an ontology. However, if we would show the JADE
ontology for arithmetic expressions we would run over the page limit.
Contrast with the three short lines used here to define $\mathit{Expr}\,a$.
The definition is not only short and readable, but also polymorphic in the
type~$a$ of the constants, and rooted in the theory of algebraic data types
(see, for example, \cite{DBLP:conf/ctcs/Hagino87}).

\begin{figure}\footnotesize % <<<
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=me]
agent foo plays Calculator Int(n)
  R-rules:
    eval(Ct(x)) <- x
    eval(Times(x, y)) <-
      n.multiply(MkPair(this.eval(x), this.eval(y)))
    eval(Plus(x, y)) <-
      n.add(MkPair(this.eval(x), this.eval(y)))
\end{lstlisting}
\end{tabular}
\end{center}
\caption{Implementing a role in 2APL}\label{fig:roleimpl2APL}
\end{figure} % >>>

The analogy is not perfect. The earlier declaration for the role
$\mathit{Calculator}\,a$ is superficially similar to the following type
class declaration.
\begin{lstlisting}[style=hs]
class Num a => Calculator a
  eval :: Expr a -> a
\end{lstlisting}
This declaration reads ``a type~$a$ that is a member of the class
\textit{Num} is also a member of class \textit{Calculator} provided there
exist a function \textit{eval} with the proper type.'' In contrast, the
earlier role declaration reads ``an \emph{unnamed} agent plays role
$\mathit{Calculator}\,a$ if it answers to messages
$\mathit{eval}(\mathit{call}(n),\ldots)$ by messages
$\mathit{eval}(\mathit{return}(),\ldots)$, where $n$~is an agent that plays
$\mathit{Num}\,a$.'' Here $a$~is a type variable.  When implementing a role
the agent must be named, as seen in Figure~\ref{fig:roleimpl2APL}. Because
\textit{foo} plays $\mathit{Calculator}\,\mathit{Int}$, the agent
interpreter creates a goal $\mathit{eval}(m,\mathit{call}(n),x)$ for all
messages with shape $\mathit{eval}(\mathit{call}(n),x)$ that come from some
agent~$m$.  One could handle these goals using 2APL's PG-rules.
\begin{lstlisting}[style=me]
eval(m, call(n), Ct(x)) <- true |
  send(m, role, eval(return(), x))
\end{lstlisting}
The first R-rule in Figure~\ref{fig:roleimpl2APL} does exactly the same,
but is more compact. The other two R-rules, however, are much more
cumbersome to simulate with the other kinds of rules. The main reason is
that the notation $n.\mathit{add}(x)$ hides sending a message
$\mathit{add}(\mathit{call}(),x)$ to agent~$n$, waiting for a reply
$\mathit{add}(\mathit{return}(),y)$, and extracting~$y$. The (goal) query
of an R-rule may only be an atom; the right side of an R-rule is an
expression that is evaluated as described and whose result is sent as a
message.  This is a rough and informal sketch of the intended semantics
that needs to be made precise.

Note that two agents \textit{foo} and \textit{bar} may be instances of the
same 2APL module, yet only \textit{foo} plays the role
$\mathit{Calculator}\,\mathit{Int}$.

In summary, the vague and informal intuition that a function is like a pair
of messages, one carrying the arguments and one carrying the result, led
us to two interesting observations. First, algebraic data types are
convenient for describing the content of messages. We expect to see fewer
runtime errors once messages are typed. Second, we developed a notion of
role in the context of the 2APL language that is independent of that of
module.

% >>>
\subsection{Types as Agents} % <<<

In the previous section, Haskell types do not have a clear analogue in
2APL. On one hand, we proposed typing message content, so it would seem
that the analogue of Haskell types are 2APL types for message content. On
another hand, agents play roles and we wrote roles much like Haskell type
classes, so it would seem that the analogue of Haskell types are 2APL
agents. A Haskell type class is a set of Haskell types; a 2APL role is a
set of 2APL agents that play the role. In this section we explore where
does the intuition ``types as agents'' lead.

{\def\l#1->#2:#3<#4>{\mathtt{#1}\to\mathtt{#2}:#3\langle\mathsf{#4}\rangle}
We read $f::a\to b$ as ``message $f$ is sent by agent~$a$ to agent~$b$.'' A
type class lists several function signatures, so its natural analogue is a
list of messages together with their endpoints. It turns out that such a
list is very similar to the global types that describe multiparty sessions
in the context of $\pi$-calculus. Here is an example of such a type from
Honda et al.~\cite{dblp:conf/popl/hondayc08}:
\begin{align*}
\mu\mathbf{t}. 
  &\l DP->K:d<bool>. \\
  &\l KP->K:k<bool>. \\
  &\l K->C:c<bool>.\mathbf{t}
\end{align*}
This type means that process \texttt{K} receives two booleans, one from
\texttt{DP} through channel~$d$ and one from \texttt{KP} through
channel~$k$, then sends a boolean to~\texttt{C} through channel~$c$, and
the whole process repeats. In 2APL we have agents, rather than processes,
and there are no named channels. We would therefore like to write the
following.
\begin{lstlisting}[style=me]
session ComputeBasicOperation(a, b)
  a -> b: Pair Int
  b -> a: Int
session ComputeExpression(a, b, c)
  c -> a: Expr Int
  repeat ComputeBasicOperation(a, b)
  a -> c: Int
\end{lstlisting}
These sessions are a global description of the messages that should flow
within an agent system. When we project $\mathit{ComputeExpression}(a,b,c)$
on agent~$a$ we obtain the role $\mathit{Calculator}\,\mathit{Int}$ from
the previous section.}

In agent-oriented methodologies it is standard to say that ``an agent plays
a role within an organisation,'' and therefore organisations are somehow
collections of interacting roles, just as the sessions above are in a way
putting together interacting roles. Similarly, in multiparty session types
there is a notion of projecting global types onto local types. The
essential advantage of session types is that the projection can be done
automatically. By imitating session types, we hope that it will be possible
to at least check automatically that the projection of a certain session on
a certain agent matches a certain role, which the agent implements.

In summary, the vague and informal intuition that a Haskell type is
sometimes like a 2APL agent led us to the proposal of specifying global
interactions in agent-oriented programming languages in terms of sessions.
Moreover, it seems reasonable to expect that a precise link between these
session and the roles proposed in the previous section can be found.

% >>> >>>
\section{Conclusions and Future Work} % <<<

Starting from high-level similarities between certain aspects of an
agent-oriented programming language (2APL) and a functional programming
language (Haskell), we described three new features for the former:
(1)~algebraic data type declarations for constraining the content of
messages, (2)~roles that are static but orthogonal to modules, and
(3)~sessions that describe slices of the global interactions in the agent
system. Together, these features offer support at the level of the
programming language for concepts that tend to be discussed mostly in the
literature on methodologies for agent-oriented design and development.

We described the proposed language features informally but, we hope, with
enough detail to convince the reader that pursuing their implementation is
a feasible and worthwhile endeavor. Our position is that many
agent-oriented programming languages would benefit from implementing these
three features. In the future, we will focus on implementing these language
features in AgentFactory~\cite{phd:rem}. This will force us to be more
precise about the semantics while staying fairly general, because
AgentFactory supports several agent-oriented programming languages. We aim
for a solution that has clear semantics, is easy to understand and use by
programmers, and enables static checking. Even if we aim for static
checking, we do plan to have runtime checks in the framework for
compliance with roles\slash sessions\slash types, because not all agents
can be trusted.

% >>>
% ending <<<
\section*{Acknowledgment}

The authors thank IRCSET for the financial support of this research.

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,rm}

% >>>
\end{document} % >>>

% vim:tw=75:fmr=<<<,>>>:fo+=t:
