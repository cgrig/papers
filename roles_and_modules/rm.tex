\documentclass[conference,compsoc]{IEEEtran}
\usepackage[cmex10]{amsmath}\interdisplaylinepenalty=2500
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[nocompress]{cite}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}


% Format notes for [conference,compsoc]
%  - do NOT use \paragraph
%  - for figures, use \centering and put captions after
%  - refer to figures with "Figure", not "Fig" (you can use \figurename)
%  - put algorithms in figures, not other floats
%  - for tables, the caption comes *before*
%  - \section*{Acknowledgment}


\title{Roles and Modules}
\IEEEspecialpapernotice{(Position Paper)}
\author{
  \IEEEauthorblockN{Rem Collier and Claudia Grigore} 
  \IEEEauthorblockA{
    School of Computer Science and Informatics\\
    University College Dublin\\
    Belfield Campus, Dublin~4, Ireland\\
    Email: rem.collier@ucd.ie, claudia.grigore@ucdconnect.ie}}

\begin{document}
\maketitle

\begin{abstract}

In Agent-Oriented Programming (AOP), roles and organisational structures
are regarded as important concepts in the analysis and design of agent
systems, but there is a significant lack of support for the implementation
stage of the development process. In response to this, a number of
organisational frameworks have emerged as powerful approaches to
implementing organisations. However, in our mind, this complicates rather
than simplifies the implementation: developers must understand and work
with both the organisational framework and the AOP language. In this paper,
we present an approach that introduces a general notion of a role for AOP
languages, the purpose of which is to reduce the gap between design and
implementation, and to offer run-time support for enforcing role
compliance. Our approach, which is inspired by Haskell's type classes,
cannot be conveniently implemented using existing AOP language concepts,
such as modules. Conversely, modules cannot be conveniently implemented
with (even our more general) roles. The two concepts are both useful in
organising large agent systems.  

\end{abstract}

\section{Introduction}

\todo{the gap between design and implementation of roles; we try to implement roles internal to agents}

\begin{notes}
AO is an evolution of OO that draws from social theory. In this paper we
illustrate how another analogy, with functional languages, helps advance 
AO\null. 
\end{notes}

\section{Background}

\todo{Rem suggested to: -- simplify the organisational centered methodologies and move it in the introduction, there's not need for the details regarding other methodologies; -- think about the flow of the paper, maybe switching the 2.2 with 2.3; -- link roles and organisations}


We assume the reader is familiar with Java and with some agent-oriented
programming language, not necessarily 2APL. We do \emph{not} assume that
the reader is familiar with Haskell.

\subsection{Organisational Centered Methodologies}

\begin{notes}
We need to connect to methodologies.
The main concepts of organisational centered multiagent systems as
presented in~\cite{DBLP:conf/aose/FerberGM03} are organisations, partition
groups, roles, tasks, and protocols. MAS analysis and design through
organisational perspective introduce an organisational level on top of
agent level. An organization is seen as a kind of dynamic framework where
agents are components, and entering a group/playing a role may be seen as a
plug-in process where a component is integrated into a framework.


An example of a methodology for designing organisations within multiagent
systems is Moise+~\cite{DBLP:conf/atal/HubnerSB05}. It has an
organisational centered orientation, the main concern being the development
of a framework that ensure the organisational constraints are being
satisfied. The organisational specification focuses on three dimensions:
structure (roles, relationships between roles, and groups), functionality
(global goals, plans, and missions) and norms (permissions, and
obligations). S-Moise+~\cite{DBLP:conf/atal/HubnerSB05} is an
organisational middleware implementing the Moise+ methodology. S-Moise+ has
two components: an OrgBox API, used by agents to access the organisational
layer, and an OrgManager agent that is responsible with maintaining the
state of the organisation.

Another example is AGR~\cite{DBLP:conf/aose/FerberGM03}, a simpler model
based on the concepts of agent, group, and role; each agent is part of one
or more groups where plays one or more roles. -- Madkit~\cite{} platform both implements and uses for its own management the AGR model. It is characterised by an extensible Agent micro-kernel (responsible of group/role management, local messaging), agentification of services (represented as roles in groups, that have been defined in an abstract organisational structure), and a graphic model based on independent components.

%Gaia

\todo{Drawbacks}

\end{notes}

\subsection{Modules in 2APL}

In Extended 2APL, agents are module
instances~\cite{DBLP:conf/prima/DastaniMS08}. At startup, the agent
interpreter creates a set of agents; later, agents may create other agents.
When an agent is created it is given a name, which can be used later to
refer to the agent. At this point, an informal analogy with Java may aid
the reader's intuition. Modules in 2APL are like classes in Java. The 2APL
action $\mathit{create}(A,x)$ placed in module~$B$ is analogous to the Java
statement $x=\mathbf{new}\,A$ placed in class~$B$ that has field~$x$.  The
analogy breaks quickly, however. For example, in 2APL it is a fault to
execute $\mathit{create}(A,x)$ twice without executing
$\mathit{release}(x)$ in-between. Hence, the number of co-existing agents
created by an instance of~$B$ is bounded by the number of distinct agent
names that appear in~$B$'s program text. (Note, however, that the total
number of agents is \emph{not} bounded, because an instance of~$A$ may
create an instance of~$B$ which creates an instance of~$A$ which creates an
instance of~$B$ and so on.)

Once an agent is created, its belief base may be queried and updated by the
agent's creator (given the proper access modifier).

Agents do \emph{not} start executing when they are instantiated. Agent~$x$
is executed synchronously by the action $x.\mathit{execute}(t)$ and
asynchronously by the action $x.\mathit{executeasync}(t)$. Coming back to
our Java analogy, these actions are like the statement
$e.\mathit{execute}(x)$, where $e$~is an instance of
$\mathit{java}.\mathit{util}.\mathit{concurrent}.\mathit{Executor}$ and
$x$~is an instance of $\mathit{java}.\mathit{lang}.\mathit{Runnable}$.  In
Java, depending on the executor, a new thread may be created or not; in
2APL, the agent is run asynchronously or not depending on which of
\textit{execute} and \textit{executeasync} is used. But again, the analogy
soon breaks. The test~$t$ has no counterpart in Java. In 2APL, when
$t$~holds, $x$~stops executing.

Other aspects of 2APL modules, such as how they interact with goals and
events, do not affect the current discussion.

\subsection{Modules and Type Classes in Haskell}

% modules
%  - small example
%  - information hiding and encapsulation
%    (exact impl may change; but it is ONE)
%  - separate compilation
%  - analogy with Java classes

Haskell modules are often used to implement abstract data types such as
sets.  To illustrate the main features of modules in little space, the code
in Figure~\ref{fig:haskell} is contrived.  The module \textit{Set} contains
the type~$T$ and the functions \textit{add}, \textit{has}, and
\textit{sub}. The \textbf{module} line hides \textit{sub} by not mentioning
it. The names and types of the exported functions \textit{add} and
\textit{has} are visible from outside the module, but their
implementations, which are to the right of~$=$, are hidden.  Similarly, the
type name~$T$ is visible from outside, but the value constructor~$V$ is
not. For example, the set $\{1,2\}$ may be represented by the value
$V[2,1,2]$, but this is not known to the users of the module \textit{Set}.
The names and types visible from outside constitute the module's
\emph{interface}.

\begin{figure}\centering\footnotesize
\begin{verbatim}
-- built-in and standard library
class Eq b where
  eq :: b -> b -> Bool
instance Eq Int where ...
elem x [] = False
elem x (y:ys) = eq x y || elem x ys
all p [] = True
all p (x:xs) = p x && all p xs

-- file set.hs
module Set (T, add, has) where
  newtype T a = V [a]
  add (V s) x = V (x:s)
  has (V s) x = elem x s
  sub (V s) t = all (has t) s

  instance Eq a => Eq (T a) where
    eq s t = sub s t && sub t s
\end{verbatim}
\caption{A Haskell module}\label{fig:haskell}
\end{figure}

In general, modules are responsible with information hiding and
encapsulation. Well known advantages come from modularity. For humans,
modular programs are easier to write and to maintain. They are easier to
write because, to a certain degree, it is enough to understand the
interface of a module in order to use it. They are easier to maintain
because changes to a module's implementation remain local as long as the
interface is not affected. For compilers, modular programs enable separate
compilation. Thus, modules are an important device in structuring large
programs. \todo{Perhaps cite some early paper on modularity.}

Haskell modules are similar, from a very high distance, to Java classes.  A
Java class hides private parts and introduces \emph{one} type at the same
time. A Haskell module may introduce zero, one, or more types.  But many
Haskell modules do indeed export \emph{one} main type. 

% type classes
%  - continue example
%  - ad-hoc polymorphism: multiple implementations with the same interface
%  - analogy with Java interfaces

The type class \textit{Eq} contains types whose values can be compared for
equality. To make a type belong to the class \textit{Eq} one must write an
instance declaration that provides an implementation for a function
named~$eq$. \todo{Should we say that we lie here a little so that we don't
confuse people who don't know Haskell?} The \textbf{instance} declaration
in module \textit{Set} says that the type constructor~$T$ transforms
members of \textit{Eq} into members of \textit{Eq}. For example, sets of
sets of integers are members of \textit{Eq}, because \textit{Int} is a
member of \textit{Eq}. Here is \emph{part} of an evaluation of the
comparison between $V[V[1]]$ and $V[V[1,1]]$, both of which
represent~$\{\{1\}\}$.
\begin{align*}
&\phantom{\;\leadsto\;}
  \mathit{eq}\;V[V[1]]\;V[V[1,1]] \\
&\leadsto
  \mathit{sub}\;V[V[1]]\;V[V[1,1]]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[V[1,1]])\;[V[1]]\\
&\leadsto
  \mathit{has}\;V[V[1,1]]\;V[1]\\
&\leadsto
  \mathit{elem}\;V[1]\;[V[1,1]]\\
&\leadsto
  \mathit{eq}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{sub}\;V[1]\;V[1,1]\\
&\leadsto
  \mathit{all}\;(\mathit{has}\;V[1,1])\;[1]\\
&\leadsto
  \mathit{has}\;V[1,1]\;1 \\
&\leadsto
  \mathit{elem}\;1\;[1,1]\\
&\leadsto
  \mathit{eq}\;1\;1\\
&\leadsto
  \mathit{True}
\end{align*}
Notice, in particular, that \textit{eq} is applied on $T(T\,\mathit{Int})$,
then on $T\,\mathit{Int}$, and then on \textit{Int}.

In general, type classes are an elegant mechanism to provide ad-hoc
polymorphism, also known as overloading~\cite{DBLP:conf/popl/WadlerB89}:
The same name refers to different implementations depending on the context.
Type classes are similar to Java interfaces but there are several key
differences~\cite{WEB:PJ-tc}. For example, in Haskell it is easy to declare
a type from one library to be an instance of a class from another library.

\section{The Analogy}

\todo{This is the last thing that we came up with: roles -- type classes, agents -- types, obligations -- functions, permissions -- data. We also considered the analogy between functions and: capabilities, protocols, activities. Consider modeling obligations with preconditions and postconditions.}

\begin{notes}
Idea: Find a clear argument of why Haskell type classes and modules are
orthogonal feature. Then find an analogy between (a part of) Haskell and (a
part of) 2APL that makes it possible to carry over the argument. Spend most
of the paper in this article on explaining the latter argument.

In general, modules are abstraction boundaries that help isolate
implementation details, and may also help compilers and interpreters to be
more efficient.  More importantly, modules help humans design and
understand large systems.

The \textit{create} action has no equivalent in Haskell. However, most
Haskell modules export \emph{one} main data type and functions to
instantiate it. For example, the module $\mathit{Data}.\mathit{Set}$
exports the type $\mathit{Set}\,a$ and the constant
$\mathit{empty}::\mathit{Set}\,a$.  We use this to extend the analogy: \[
\textit{2APL module} \sim \textit{Haskell module} \sim \textit{Haskell
type}. \]

Type classes are sets of types, all of which support similar operations.
The analogy would then be a set of 2APL modules, all of which support
similar operations. Except there's no notion of ``operation'' so we must
find a suitable analogue.

A function of type $s\to t$ takes an object of type $s$ and returns one of
type~$t$. The analogy now cracks a bit: Haskel's types were supposed to be
like 2APL modules (at least the types that are the ``main'' ones in some
module); however, something that takes modules and produces modules is more
like an OCaml functor, and putting that in a type-class sounds $\ldots$
complicated. The goal here is to be able to mix and match different modules
in certain context, just like type classes allow you to use different
implementations for fixed point addition and floating point addition
without sweating about it.

So, let's take a step backward: If not all Haskell types are ``main'' and
therefore analogue to 2APL modules, then what is their analogue? One
possibility is messages. So a function of type $s\to t$ is like a promise:
``If you give me message~$s$, I will (eventually) send you back a
message~$t$.'' Another possibility is beliefs: ``If now I believe~$s$,
(there's a good chance) I'll evolve to believe~$t$.''

\end{notes}

\section{Example}

\begin{notes}
Ideally, a 2APL program that uses the proposed roles, and that is 
cumbersome to write using only modules or only roles.
\end{notes}

\section{Other Languages}

\begin{notes}
Do roles make sense in other agent programming languages? Since AgentFactory
supports multiple agent programming languages, it provides a great setting
for exploring this question.
\end{notes}

\section{Conclusion}

\section*{Acknowledgment}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,rm}

\section*{Notes}

Roles (like type classes) can have more than one implementation: Each agent
plays a role in its own way.


\end{document}

% vim:tw=75:
