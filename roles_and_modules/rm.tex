\documentclass[conference,compsoc]{IEEEtran}
\usepackage[cmex10]{amsmath}\interdisplaylinepenalty=2500
\usepackage[british]{babel}
\usepackage[nocompress]{cite}
\usepackage{microtype}
\usepackage{xcolor}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}


% Format notes for [conference,compsoc]
%  - do NOT use \paragraph
%  - for figures, use \centering and put captions after
%  - refer to figures with "Figure", not "Fig" (you can use \figurename)
%  - put algorithms in figures, not other floats
%  - for tables, the caption comes *before*
%  - \section*{Acknowledgment}


\title{Roles and Modules}
\IEEEspecialpapernotice{(Position Paper)}
\author{
  \IEEEauthorblockN{Rem Collier and Claudia Grigore} 
  \IEEEauthorblockA{
    School of Computer Science and Informatics\\
    University College Dublin\\
    Belfield Campus, Dublin~4, Ireland\\
    Email: rem.collier@ucd.ie, claudia.grigore@ucdconnect.ie}}

\begin{document}
\maketitle

\begin{abstract}

In Agent-Oriented Programming (AOP), roles and organisational structures
are regarded as important concepts in the analysis and design of agent
systems, but there is a significant lack of support for the implementation
stage of the development process. In response to this, a number of
organisational frameworks have emerged as powerful approaches to
implementing organisations, however, in our mind, this complicates rather
than simplifies the implementation: developers must understand and work
with both the organisational framework and the AOP language. In this paper,
we present an approach that introduces a general notion of a role for AOP
languages, the purpose of which is to reduce the gap between design and
implementation, and to offer run-time support for enforcing role
compliance. Our approach, which is inspired by Haskell's type classes,
cannot be conveniently implemented using existing AOP language concepts,
such as modules. Conversely, modules cannot be conveniently implemented
with (even our more general) roles. The two concepts are both useful in
organising large agent systems.  

\end{abstract}

\section{Introduction}

\begin{notes}
AO is an evolution of OO that draws from social theory. In this paper we
illustrate how another analogy, with functional languages, helps advance 
AO\null. 
\end{notes}

\section{Background}

We assume the reader is familiar with Java and with some agent-oriented
programming language, not necessarily 2APL. We do \emph{not} assume that
the reader is familiar with Haskell.

\subsection{Moise+}

\begin{notes}
We need to connect to methodologies.
\end{notes}

\subsection{Modules in 2APL}

In Extended 2APL, agents are module
instances~\cite{DBLP:conf/prima/DastaniMS08}. At startup, the agent
interpreter creates a set of agents; later, agents may create other agents.
When an agent is created it is given a name, which can be used later to
refer to the agent. At this point, an informal analogy with Java may aid
the reader's intuition. Modules in 2APL are like classes in Java. The 2APL
action $\mathit{create}(A,x)$ placed in module~$B$ is analogous to the Java
statement $x=\mathbf{new}\,A$ placed in class~$B$ that has field~$x$.  The
analogy breaks quickly, however. For example, in 2APL it is a fault to
execute $\mathit{create}(A,x)$ twice without executing
$\mathit{release}(x)$ in-between. Hence, the number of co-existing agents
created by an instance of~$B$ is bounded by the number of distinct agent
names that appear in~$B$'s program text. (Note, however, that the total
number of agents is \emph{not} bounded, because an instance of~$A$ may
create an instance of~$B$ which creates an instance of~$A$ which creates an
instance of~$B$ and so on.)

Once an agent is created, its belief base may be queried and updated by the
agent's creator (given the proper access modifier).

Agents do \emph{not} start executing when they are instantiated. Agent~$x$
is executed synchronously by the action $x.\mathit{execute}(t)$ and
asynchronously by the action $x.\mathit{executeasync}(t)$. Coming back to
our Java analogy, these actions are like the statement
$e.\mathit{execute}(x)$, where $e$~is an instance of
$\mathit{java}.\mathit{util}.\mathit{concurrent}.\mathit{Executor}$ and
$x$~is \todo{Can we rename this x if is not related to agent x? It confuses
me.} an instance of $\mathit{java}.\mathit{lang}.\mathit{Runnable}$.  In
Java, depending on the executor, a new thread may be created or not; in
2APL, the agent is run asynchronously or not depending on which of
\textit{execute} and \textit{executeasync} is used. But again, the analogy
soon breaks. The test~$t$ has no counterpart in Java. In 2APL, when
$t$~holds, $x$~stops executing.

Other aspects of 2APL modules, such as how they interact with goals and
events, do not affect the current discussion.

\subsection{Modules in Haskell}

\begin{notes}
I guess the ADT \todo{abstract data types?} explanation should suffice.
\end{notes}

\subsection{Type Classes in Haskell}

\begin{notes}
Type Classes were originally introduced by~\cite{DBLP:conf/popl/WadlerB89}.

Explain the analogy with Java interfaces and what are the differences.
(PJ's ECOOP~2009 invited talk slides discuss this explicitly.)
\end{notes}

\section{The Analogy}

\begin{notes}
In general, modules are abstraction boundaries that help isolate
implementation details, and may also help compilers and interpreters to be
more efficient.  More importantly, modules help humans design and
understand large systems.

The \textit{create} action has no equivalent in Haskell. However, most
Haskell modules export \todo{what does it mean for a module to export?  }
\emph{one} main data type and functions to instantiate it \todo{does this
mean that a module is equivalent to a type?}.  For example, the module
$\mathit{Data}.\mathit{Set}$ exports the type $\mathit{Set}\,a$ and the
constant $\mathit{empty}::\mathit{Set}\,a$. We use this to extend the
analogy: \[ \textit{2APL module} \sim \textit{Haskell module} \sim
\textit{Haskell type}. \]

Type classes are sets of types, all of which support similar operations.
The analogy would then be a set of 2APL modules, all of which support
similar operations. Except there's no notion of ``operation'' so we must
find a suitable analogue.\todo{why can't the actions that an agent can
perform  be considered operations in the 2APL modules?}

A function of type $s\to t$ takes an object of type $s$ and returns one of
type~$t$. The analogy now cracks a bit: Haskel's types were supposed to be
like 2APL modules (at least the types that are the ``main'' ones in some
module); however, something that takes modules and produces modules is more
like an OCaml functor, and putting that in a type-class sounds $\ldots$
complicated. The goal here is to be able to mix and match different modules
in certain context, just like type classes allow you to use different
implementations for fixed point addition and floating point addition
without sweating about it.

So, let's take a step backward: If not all Haskell types are ``main'' and
therefore analogue to 2APL modules, then what is their analogue? One
possibility is messages. So a function of type $s\to t$ is like a promise:
``If you give me message~$s$, I will (eventually) send you back a
message~$t$.'' Another possibility is beliefs: ``If now I believe~$s$,
(there's a good chance) I'll evolve to believe~$t$.''

\end{notes}

\section{Example}

\begin{notes}
Ideally, a 2APL program that uses the proposed roles, and that is 
cumbersome to write using only modules or only roles.
\end{notes}

\section{Other Languages}

\begin{notes}
Do roles make sense in other agent programming languages? Since AgentFactory
supports multiple agent programming languages, it provides a great setting
for exploring this question.
\end{notes}

\section{Conclusion}

\section*{Acknowledgment}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,rm}

\section*{Notes}

Roles (like type classes) can have more than one implementation: Each agent
plays a role in its own way.


\end{document}

% vim:tw=75:
