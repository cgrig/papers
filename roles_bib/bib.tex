% header {{{1
\documentclass{article}
% packages {{{2
\usepackage[annote]{babelbib}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}
% macros {{{2
\newcommand{\fb}[1]{\textbf{#1}}
\newcommand{\rg}[1]{{\small[\textcolor{red}{TODO}: #1]}}
\newenvironment{notes}{\medskip\hrule\smallskip\narrower}{\smallskip\hrule\medskip}
\renewcommand{\btxannotation}[1]{\par\noindent\textit{#1}}
\renewcommand{\sectionautorefname}{Section}

% title, author, ... {{{2
\title{An Annotated Bibliography of Roles in Agent-Oriented Programming}
\begin{document}
\maketitle

% abstract {{{1
\begin{abstract}
We survey the literature and the tools related to roles as used in agent-oriented programming.
The focus is on practical advances, which may be of interest to software developers.
\end{abstract}

\section{Introduction}\label{sec:introduction} %{{{1

AOP (\fb agent-\fb oriented \fb programming) is an alternative to OOP (\fb object-\fb oriented \fb programming).
Very roughly, agents replace objects, logic formulas replace primitive values, messages replace method calls, and roles replace classes and interfaces.
Just as interfaces are very useful for developing large OO programs, so are roles very useful for developing large agent systems.

We are not aware of any large ($>100{,}000$ lines of code) agent system.
This may be because agent-oriented development tools, in general, and tools that support roles and organizations, in particular, are just beginning to mature.
There exist however a few agent systems, some of them fun, some of them useful, and some of them even using roles.

In practice, the line between agent systems and non-agent systems is not clear cut.
At one extreme, one could use an agent programming language and write the program in a traditional style, without using in an essential way any of the high-level agent concepts; at the other extreme, one could write a program in C and organize it into agents that maintain state as logic formulas and communicate through messages.
Similarly, one could write procedural code in Java, and object-oriented code in C\null.
Since programming style is involved, it is hard to find hard and fast criteria for what constitutes an agent system.
Still, some guidelines are useful.
When a significant part of a system is a collection of interacting agents, we may call it an agent system.
A part of a system qualifies as an agent only if it is fairly autonomous, much more so than a typical object.
If that part of the system also maintains its state using logic formulas, then we should feel confident in calling it an `agent'.

Let us look at some examples.

RoboCup~\cite{journals/robotics/KitanoANM1998,site/robocup} is a fun yearly competition with multiple tracks.
One of them, the simulation track, is a soccer contest with rules similar to the real World Cup.
Each team consists of 12~agents: 10~field players, 1~goalie, and 1~coach.
The environment and players' resources (like stamina) are managed by a server, which has $\approx48$ thousand lines of code.
The team members interact with the server through UDP, so there is no incentive to code them in the same language as the server.
The initial RoboCup server was written by researchers working on multi-agent systems.
Subsequently, it helped research in other fields, particularly in artificial intelligence.

A new competition~\cite{site/mas_contest}, focusing on agents, started in~2005.
The format is similar---a few clients written by competitors interact with a server written by organizers over a generic protocol.
The tasks include herding cows, mining gold, gathering food.
The organizers of the 2011 edition feel that previous competitions did not do enough to encourage a multi-agent programming style.
The source code of the 2011 participants is available online.


\begin{notes}
\emph{Examples of agent systems}

\paragraph{Erlang}
IIRC, this language is designed for writing distributed systems.
See also \url{http://en.wikibooks.org/wiki/Erlang_Programming/Autonomous_Agents}.

\end{notes}

Next (\autoref{sec:implementations}), we list the main development environments (interpreters, libraries, etc.) that support roles and compare them with regards to various characteristics.
Then (\autoref{sec:general_nonsense}), we present the main methodologies and conceptual models  that complement and motivate the existing implementations.

\section{Implementations}\label{sec:implementations} %{{{1

The following implementations are of high-quality and are actively developed.
\begin{itemize}
\item Jason~\cite{books/sp/map2005/BordiniHV05}
\item 3APL~\cite{books/sp/map2005/DastaniRM05}
\item GOAL~\cite{hindriks2009programmingrationalagents}
\item Jadex~\cite{todo}
\item Aglet~\cite{todo}
\item The RoboCup soccer simulator
\item AgentFactory
\end{itemize}

\section{Methodologies and Conceptual Models}\label{sec:general_nonsense} %{{{1

\section{Conclusions}\label{sec:conclusions} %{{{1

\section{Working Notes} %{{{1
Methodologies that emphasize social aspects:
\begin{itemize}
\item GAIA~\cite{journals/aamas/WooldridgeJK00}
\item INGENIAS
\item MESSAGE
\item SODA
\end{itemize}
Metamodels that emphasize social aspects:
\begin{itemize}
\item AGR~\cite{conf/aose/FerberGM03}
\item RIO
\end{itemize}

TODO: Perl has roles! That \emph{must} be mentioned.

NOTE: There's a slew of abstract work that we ignore, because we focus on those research contributions that resulted in executable artefacts.

Test text:
AOP~\cite{journals/ai/Shoham93} is a fairly new programming paradigm.
Also, Gaia~\cite{journals/aamas/WooldridgeJK00} is so cool.
Software engineering is better ever since~\cite{conf/aose/WooldridgeC00}.

% footer {{{1
\bibliographystyle{babplain-fl}
\bibliography{bib}
\end{document}

% see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.33.8207&rep=rep1&type=pdf

