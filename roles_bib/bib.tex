% header {{{
\documentclass{article}

% packages {{{
\usepackage[annote]{babelbib}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

% }}}
% macros {{{
\newcommand{\fb}[1]{\textbf{#1}}
\newcommand{\rg}[1]{{\small[\textcolor{red}{TODO}(rg): #1]}}
\newenvironment{notes}{\medskip\hrule\smallskip\narrower}{\smallskip\hrule\medskip}
\renewcommand{\btxannotation}[1]{\par\noindent\textit{#1}}
\renewcommand{\sectionautorefname}{Section}

% }}}
% title, author, ... {{{
\title{An Annotated Bibliography of Roles in Agent-Oriented Programming}
\begin{document}
\maketitle

% }}}
% }}}
% abstract {{{
\begin{abstract}
We survey the literature and the tools related to roles as used in agent-oriented programming.
The focus is on practical advances, which may be of interest to software developers.
\end{abstract}

% }}}

\section{Introduction}\label{sec:introduction} %{{{

AOP (\fb agent-\fb oriented \fb programming) is an alternative to OOP (\fb object-\fb oriented \fb programming).
Very roughly, agents replace objects, logic formulas replace primitive values, messages replace method calls, and roles replace classes and interfaces.
Just as interfaces are very useful for developing large OO programs, so are roles very useful for developing large agent systems.

\rg{It may very well be that all implementations for Internet Mail break this barrier. Internet browsers are definitely bigger. Rethink this paragraph.}
We are not aware of any large ($>100{,}000$ lines of code) agent system.
This may be because agent-oriented development tools, in general, and tools that support roles and organizations, in particular, are just beginning to mature.
There exist, however, a few agent systems, some fun, some useful, and some even using roles.

In practice, the line between agent systems and non-agent systems is not clear cut.
At one extreme, one could use an agent programming language and write the program in a traditional style, without using in an essential way any of the high-level agent concepts; at the other extreme, one could write a program in C and organize it into agents that maintain state as logic formulas and communicate through messages.
Similarly, one could write procedural code in Java, and object-oriented code in C\null.
Since programming style is involved, it is hard to find hard and fast criteria for what constitutes an agent system.
Still, some guidelines are useful.
When a significant part of a system is a collection of interacting agents, we may call it an agent system.
A part of a system qualifies as an agent only if it is fairly autonomous, much more so than a typical object.
If that part of the system also maintains its state using logic formulas, then we should feel confident in calling it an `agent'.

Let us look at some examples.

RoboCup~\cite{journals/robotics/KitanoANM1998,site/robocup} is a fun yearly competition with multiple tracks.
One of them, the simulation track, is a soccer contest with rules similar to the real World Cup.
Each team consists of 12~agents: 10~field players, 1~goalie, and 1~coach.
The environment and players' resources (like stamina) are managed by a server, which has $\approx48$ thousand lines of code.
The team members interact with the server through UDP, so there is no incentive to code them in the same language as the server.
The initial RoboCup server was written by researchers working on multi-agent systems.
Subsequently, it helped research in other fields, particularly in artificial intelligence.

A new competition~\cite{site/mas_contest}, focusing on agents, started in~2005.
The format is similar---a few clients written by competitors interact with a server written by organizers over a generic protocol.
Past tasks include herding cows, mining gold, and gathering food.
The organizers of the 2011 edition feel that previous competitions did not do enough to encourage a multi-agent programming style.
The source code of the 2010 participants is available online.

These agent systems are fun and push the boundaries; 
other agent systems are useful and robust.

Internet mail has an agent-oriented architecture~\cite{rfc/5598}.
There are five types of agents, distinguished by the functions they perform: message user agent, message submission agent, message transfer agent, message delivery agent, and message store.
Functions fulfill responsibilities, responsibilities are grouped into roles, and agents act in roles.
Roles come in two flavors, based on whether fulfilling them requires looking inside the envelope.
The user actors are: authors, recipients, return handlers, and mediators.
The infrastructure actors are: originator, relay, receiver, and gateway.

Internet mail agents are autonomous.
For example, if a message transfer agent is shut down for not too long, then message delivery may be delayed but does not otherwise suffer.
Other agents are autonomous and know how to deal with an unresponsive message transfer agent.
Such resilience owes to the lack of state.
The only agent whose state is important is the message store.

The Internet mail architecture has many implementations.
User agents come bundled in an email client (Microsoft Outlook, GMail) and infrastructure agents come bundled in an email server (sendmail, postfix).
In postfix~\cite{site/postfix}, agents are implemented as operating system processes, so they are indeed loosely coupled.

\begin{notes}
\emph{Examples of agent systems}

\paragraph{Erlang}
IIRC, this language is designed for writing distributed systems.
See also \url{http://en.wikibooks.org/wiki/Erlang_Programming/Autonomous_Agents}.
``Everything is a process.''
Processes communicate thru messages.
Functional.
There is a framework called \fb erlang e\fb Xperimental \fb Agent \fb Tool.

\paragraph{Browsers}
Browsers are called ``HTTP user agents''.
The other HTTP user agents are usually browser-like software libraries.

\paragraph{Chat-bots}

\end{notes}

Next (\autoref{sec:implementations}), we list the main development environments (interpreters, libraries, etc.) that support roles and compare them with regards to various characteristics.
Then (\autoref{sec:general_nonsense}), we present the main methodologies and conceptual models  that complement and motivate the existing implementations.

\section{Implementations}\label{sec:implementations} %{{{1

The following implementations are of high-quality and are actively developed.
\begin{itemize}
\item Jason~\cite{books/sp/map2005/BordiniHV05}
\item 3APL~\cite{books/sp/map2005/DastaniRM05}
\item GOAL~\cite{hindriks2009programmingrationalagents}
\item Jadex~\cite{todo}
\item Aglet~\cite{todo}
\item The RoboCup soccer simulator
\item AgentFactory
\end{itemize}

\section{Methodologies and Conceptual Models}\label{sec:general_nonsense} %{{{1

\section{Conclusions}\label{sec:conclusions} %{{{1

\section{Working Notes} %{{{1
Methodologies that emphasize social aspects:
\begin{itemize}
\item GAIA~\cite{journals/aamas/WooldridgeJK00}
\item INGENIAS
\item MESSAGE
\item SODA
\end{itemize}
Metamodels that emphasize social aspects:
\begin{itemize}
\item AGR~\cite{conf/aose/FerberGM03}
\item RIO
\end{itemize}

TODO: Perl has roles! That \emph{must} be mentioned.

NOTE: There's a slew of abstract work that we ignore, because we focus on those research contributions that resulted in executable artefacts.

Test text:
AOP~\cite{journals/ai/Shoham93} is a fairly new programming paradigm.
Also, Gaia~\cite{journals/aamas/WooldridgeJK00} is so cool.
Software engineering is better ever since~\cite{conf/aose/WooldridgeC00}.

% footer {{{1
\bibliographystyle{babplain-fl}
\bibliography{bib}
\end{document}

% see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.33.8207&rep=rep1&type=pdf

