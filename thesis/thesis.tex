\documentclass[a4paper,12pt,oneside,fleqn]{book} %<<<
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{arev}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\theoremstyle{plain}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\eox}[1]{\hskip5mm\null\nobreak\hfill#1}
\newcommand{\eoe}{\eox{(end of example)}}
\newcommand{\eor}{\eox{(end of remark)}}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\rg}[1]{\marginpar{\tiny\raggedright\textcolor{blue}{\bf rg:} #1}}
\newcommand{\todo}[1]{[\textcolor{red}{TODO}: #1]}

\setlength{\marginparwidth}{95pt}
\setlength{\mathindent}{3em}

% PDF settings <<<
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.95,0.95,0.95}
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
%\hypersetup{colorlinks=false}
\hypersetup{
  pdfauthor={Claudia V. Grigore},
  pdftitle={Supporting Agent Systems in the Programming Language}}
% >>>
% >>>
\begin{document} % <<<
\overfullrule=5pt \pretolerance=400 \tolerance=200 % temporary
\title{Supporting Agent Systems in the Programming Language} % <<<
\author{Claudia V. Grigore}
\date{August 2013}
\maketitle

\pagenumbering{roman}
\tableofcontents
\listoffigures
\listoftables
% >>>
\baselineskip=21.75pt
\parskip=3pt plus 3pt minus 3pt
\chapter*{Acknowledgements} % <<<

% >>>
\chapter*{Abstract} % <<<

This thesis defines a novel agent-oriented programming language, called
AF-RAF\null.  The agent-oriented paradigm is just beginning to make strides
into the practice of programming distributed, asynchronous systems.
Several methodologies identified the need for organising principles, which
tend to be inspired by theories of sociology and economy.  In particular,
several methodologies make use of the concepts of role and organisation.
The exact meaning of these concepts varies from one methodology to the
other, and lacks a formal definition.  The primary goal of the AF-RAF
design is to concretise the concepts of role and organisation at the level
of a programming language, thus giving them rigorous meaning. The
development is done in the context of the AgentFactory framework.  Unlike
most agent-oriented programming languages, AF-RAF is mostly a functional
language, with few imperative constructs.  Numerous examples illustrate the
elegance of AF-RAF's design.


% >>>
\chapter*{Plan --- to be commented} % <<<

\begin{enumerate}
\item introduction
\item preliminaries
  \begin{enumerate}
  \item role theory
  \item organisational theory
  \item logic
    \begin{itemize}
    \item terms, formulas
    \item sorts
    \end{itemize}
  \item functional languages
    \begin{itemize}
    \item algebraic data types and type-checking
    \item modules
    \item type classes
    \end{itemize}
  \item session types
  \item agentfactory
  \end{enumerate}
\item usage scenarios
  \begin{itemize}
  \item give many examples of use
  \end{itemize}
\item language definition
  \begin{itemize}
  \item syntax
  \item semantics
  \end{itemize}
\item related work
  \begin{itemize}
  \item review other languages
  \end{itemize}
\item conclusions
\end{enumerate}

% >>>
\chapter{Introduction}\label{ch:intro} % <<<
\pagenumbering{arabic}

Research in multi-agent systems thrived since $\sim2000$.
Very recently, it began to impact the practice of programming.

Complex systems are often viewed as being hierarchically decomposed into layers
of subsystems that interact with one another in an inherently decentralized
manner. It is increasingly accepted that this natural lack of an upper layer of
control, together with the tendency within such systems for interaction to
occur between components that are situated within the same layer has a close
synergy with the concept of a multi-agent
system~\cite{Jennings00agent-orientedsoftware}. Multi-agent systems promote a
view of distributed systems as a collection of intelligent (agent) components
that are autonomous and which interact in a way that is highly disciplined and
well defined. Further, through this interaction, agents are able to cooperate
as necessary, allowing competing system objectives to be realized in a context
sensitive fashion.

While the above argument presents a strong case for the use of a multi-agent
systems approach in the design and implementation of complex distributed
systems, it is not enough. It must be supplemented through the provision of
appropriate programming languages, toolkits, and software engineering
methodologies that support and facilitate the adoption of an agent-oriented
perspective. Further, it is paramount that the use and value of these artifacts
be demonstrated and validated through their extensive use within a range of
real world application domains. In response to this, the multi-agent systems
research community has created a range of implementation environments, such as
JADE~\cite{DBLP:books/sp/map2005/BellifemineBCP05}, Agent
Factory~\cite{collier1999agent}, ZEUS~\cite{DBLP:conf/agents/NwanaNLC99},
together with a nascent set of standards developed by the Foundation for
Intelligent Physical Agents (FIPA), and a diverse set of software engineering
methodologies, such as GAIA~\cite{DBLP:journals/aamas/WooldridgeJK00}, Agent
UML~\cite{bauer2001agent}, MaSE~\cite{deloach2001analysis}, and
Prometheus~\cite{DBLP:conf/atal/PadghamW02}.

One approach to implement agent systems is Agent Oriented Programming (AOP).
This relatively new paradigm ``promotes a societal view of computation, in which
multiple agents interact with one another''~\cite{DBLP:journals/ai/Shoham93}.
The agent is the fundamental unit of computation, analysed and controlled using
mental terms.  The state of an agent is restricted to mental components, such
as beliefs, commitments, capabilities. AOP tries to match the programmer
intuition to the formal concepts in the same way the Object Oriented
Programming (OOP) paradigm did before.

AOP can be viewed as a specialisation of OOP\null. OOP sees the
computational system as made of units that are able to communicate using
messages. AOP makes this framework more specific by restricting the state
of the unit to consist only of mental components, and by restricting the
types of valid messages to those specified in an underlying agent
communication language.

A number of AOP languages have been developed to date, such as
Agent-0~\cite{DBLP:journals/ai/Shoham93},
AgentSpeak(L)~\cite{DBLP:conf/maamaw/Rao96},
2APL~\cite{DBLP:journals/aamas/Dastani08},
3APL~\cite{DBLP:conf/promas/DastaniRDM03}, and
AFAPL~\cite{DBLP:conf/seke/CollierOR04}. The research in this area has focused
on clearly defining the reasoning process, linking these processes to the
agents environment, and generally trying to improve the usability of the
languages via better tool support.

Agent Oriented Software Engineering aims to offer methodologies and toolkits
for structuring agent development. A new trend in AOSE methodologies is to support organisational design for building dynamic agent organisations.

This approach will be crucial for domains like grid and ubiquitous
computing~\cite{luck2005agent}. The concept of organisation is studied in
several disciplines including sociology, economy and psychology. AOSE tries to
integrate theories that were developed in other disciplines, such as the Role
Theory~\cite{biddle1986recent}, and their associated concepts, to model agent
organisation and to structure interactions between the agents inside of the
organisation. One example in this direction is AALAADIN, a meta-model of
multi-agent systems~\cite{ferber1998meta}.

Implementation-level support for these concepts is a research area. One
approach is to design organisational models and frameworks such as BRAIN, Moise+, GAIA, and MaSE.

MaSE methodology \cite{deloach2004mase} is an organisational approach to
analysis and design of MAS. It also supports the implementation through the
associated AgentTool development system. Both MaSe and AgentTool are
independent of any particular agent architecture, programming language or
communication framework. The \emph{analysis} phase define system goals from
a set of requirements and then define the roles necessary to meet the
goals. A role consists of a number of tasks, where a task corresponds to a
goal. Each task has its own thread of control, but may communicate with
each other. The \emph{design} phase assigns roles to agent classes,
identify and constructs conversations (coordination protocols between two
agents), define the internal agent architecture and the final system
structure.

Gaia \cite{DBLP:journals/aamas/WooldridgeJK00} is a two phased methodology for
analysing and designing multiagent systems. The analysis phase aims to collect
and organise specifications. This includes identification of organisational
goals, expected global behaviour, and decomposition in sub-organisations. Its
output consists of a model of the environment, a preliminary model of roles, a
preliminary model of interactions, and organisational rules. The design phase
is split in two: the architectural design and the detailed design. The
architectural design includes the definition of the organisational structure in
terms of its topology and control regime, as well as the completion of the
preliminary role and interaction models. The detailed design phase covers the
definition of the agent model based on the role model and the definition of the
services model, where services correspond to blocks of activity required to
realise agent's roles.

The Moise+ \cite{DBLP:conf/sbia/HubnerSB02} organisational model is the first one to
join roles with plans. It consists of three main dimensions: structural,
functional and deontic. Roles represent the structural, plans are the
functional, and the relations between roles and plans represent the deontic
dimension. Saci-Moise+, Jason-Moise+ and Moise+JavaAPI frameworks are
implementations of the Moise+ meta-model.

The BRAIN Framework \cite{DBLP:conf/coopis/CabriLZ03} supports the development
of interactions in agent-based applications, using the concept of role. It
consists of (1)~an interaction model, (2)~an XML-based notation to express
roles (XRole), and (3)~an interaction infrastructure implementation
(Rolesystem). A role is defined as a set of capabilities and has an expected
behaviour. Capabilities are activities that an agent can perform.

A different approach to support the implementation of organisational
concepts would be to develop custom programming languages, in the context
of Agent Oriented Programming. The majority of AOP languages are based on
theories from mid-nineties and do not reflect the increased importance of
organisations in multi-agent system design.

\subsubsection{Hypotheses and Objectives}
Agent Oriented Programming, a relatively new programming paradigm, adopts a
social metaphor for the design and implementation of software systems.
Specifically, software systems are viewed as communities of software entities,
known as agents, that interact with one another in order to solve problems that
are beyond their individual capabilities. It is widely accepted that this
approach is well suited to problem domains in which there is no global system
control, data is decentralised and computation is asynchronous.

Agent-oriented methodologies emphasize organisational concepts, which give
structure to large agent systems. Organisational frameworks, however, put
an extra burden on developers, who need to master both an agent-oriented
programming language and the framework itself. We believe that the
organisation of agent systems should be directly supported by features of
the programming language.

Even though organisations are increasingly seen as an important concept in
agent oriented design, little work has been done on applying organisational
concepts to AOP languages. Integrating the concept of roles offers
significant advantages. They are a natural metaphor for describing the overall
system behaviour, and they increase the adaptability and flexibility of agent
systems by offering the appropriate level of granularity. Roles define a set of
related behaviours, encapsulating them realises a separation of concerns and
promotes information hiding.

The primary hypothesis of my research is that the integration of roles,
based on sociological Role Theory, will improve the readability and
usability of AOP languages. The objective is to develop a novel AOP
language that employs roles, based on the existing Agent Factory framework.
\rg{Maybe promise only that you show how roles, a concept from sociology,
maps to a programming language construct.}

\subsubsection{Methodology}
In order to achieve this objective I have adopted the following approach:
\rg{When somebody reads your thesis, they want to know about the subject of
the thesis, not about you as a person.  Whether you attended classes or not
is irrelevant to them.}

\begin{itemize}
\item attending courses, seminaries, and summer schools on various agent topics
to broad my view and understanding of the area.

\item reading and summarising papers on agents, roles, and organisations, for a
deeper understanding of the specific problem of integrating organisational
concepts into AOP languages.

\item solving concrete problems to attain a better understanding of MAS
toolkits and AOP languages.

\item taking inspiration from other programming languages in order to device appropriate programming language features to support organisational concepts that are discussed in the literature on agent-oriented methodologies and frameworks.

\end{itemize}

\subsubsection{Progress to date}

\begin{itemize}
\item attended courses
  \begin{itemize}
  \item Principles of Programming Languages
  \item Object Oriented Design
  \item Social Networks and Agent-based Simulation
  \item Research Skills
  \item Research Seminaries
  \end{itemize}
\item attended the EASSS 2009 summer school in Torino
\item explored the use of Social Network Analysis techniques in agent systems
\item
  researched the current state of the art in the area of organisations in MAS:
  theoretical models of organisations and implementations

\item understanding MAS toolkits by solving problems
\item presentation on MAS in UCD's Research Seminar Series
\item
  I took inspiration from other programming languages, in special from the
  functional programming language Haskell, and proposed three language features
  to support organisational concepts, namely: (1) algebraic data types, which
  constrain the content of the messages, (2) roles, which constrain how
  particular agents interact, and (3) sessions, which describe slices of the
  global interactions in the agent systems.

\item
  having specified and started to implement the new AF-Raf programming
  language. AF-Raf supports directly the organisation of agent systems through
  programming language features including algebraic data types, roles, and
  sessions.

\item publications to date
  \begin{itemize}
  \item ``Supporting Agent Systems in the Programming Language", COIN @ WI-IAT 2011
  \item ``AF-Raf: An Agent-Oriented Programming Language with Algebraic Data Types", AGERE @ Splash 2011
  \end{itemize}
\end{itemize}

% >>>
\chapter{Preliminaries} % <<<

TODO

\section{Role Theory} % <<<

TODO
 
The Role Theory (RT) elaborated in Sociology and Social Psychology tries to
explain the predictability of individual behaviour by linking it to the
social structures. RT can be described using the theatre metaphor, where
individuals are actors enacting a role in a play. There are several
approaches to RT, each with slightly different definitions of roles, but
the common idea is that each role has associated some behavioral
expectations. Conformity or nonconformity to these expectations trigger
rewards or punishments. These behavioral expectations can be expressed as
rights and duties, and are guided by social norms.

According to B.J. Biddle~\cite{} there are five major approaches to RT: The
Functional Role Theory have a static understanding of roles, which are seen
as a set of expectations from the society, inflexible and universally
agreed upon; In The Interactionist Perspective interpersonal interaction is
of major importance, roles being negotiated between individuals on a
constant basis; The Structural Perspective focus more on social structures
like the one of status as the key concept in role definition;
Organisational Role Theory looks at the development of roles in the context
of preplanned and task oriented social systems; The Cognitive Role Theory
emphasizes the relationship between expectations and behaviour.

Role Theory bridges individual behaviour and social structure. Roles as
social constructs influence individual behaviour on different levels. They
have associated characteristic beliefs and attitudes, meaning that whenever
roles are changing beliefs and attitudes change along. Also roles specify
goals, tasks and performance standards required in specific social
situations, acting as plans or blueprints to guide behaviour.

An individual plays multiple roles over time, and at the same time. As a
result roles interact not only at the social level, but at the individual
level as well. A number of issues arise such as role conflict, role strain,
role overload, on the negative side, and role accumulation on the positive
side.

In summary, Role Theory could be synthesised as follows: Social situations
are governed by social norms, which determine behavioral expectations,
which are in turn described in term of duties and rights or obligations and
permissions. The expectations are both internal and external to the
individual. Conformity results in rewards while nonconformity triggers
social sanctions. Role prescriptions are subject to change through social
pressure.

Guido Boella on Roles, Graversen on Roles in OOP

Role oriented programming languages: Object Teams, PowerJava, EpsilonJ,
Chameleon, Perl 6, Perl 5
% >>>
\section{Organisational Theory}  % <<<

TODO

Organisational Theory is a discipline of social sciences for more than 100
years. Organisational Theory studies organisational design, organisational
structures, the relationship of organisations with their environment, and
the behaviour of individuals in organisational settings. 

An organisation could be regarded as a coordinated collective action
towards a common goal. Organisations are governed by rules and placed
within an environment. 

The study of formal organisations accompanied the industrial
revolution, following the need to organise labour. There are a number of
organisational theories that can be categorised in three groups or stages
depending on their main focus: classical theories focus on the product,
neoclassic theories focus on the employee, and contemporary theories focus
on the environment.~\cite{}J. Doherty

Each of the Organisational Theories can be described in terms of the four
components of a division of labour: the hierarchy of authority, the span of
control, the level of centralisation versus decentralisation in decision
making, and the specialisation of functions or tasks.

The hierarchy of authority refers to a system of rules regarding the line
of communication and control, which determine the organisational structure.
In this context focusing on the specialisation of tasks results in
functional organisations, while focusing on the end product results in
product organisations. Focusing on both function and product results in a
matrix organisation with a dual authority.

The span of control can be narrow resulting in a high organisation, with
multiple levels or wide resulting in a flat organisation, with fewer levels.

The centralisation and decentralisation refers to the number of people and
the grade in which people are involved in decision making. In centralised
organisation the number of people involved in decision making is small,
representing the upper-level in the authority hierarchy. In decentralised
organisations the decision making is delegated to all levels.

Regarding the specialisation, a high degree of specialisation means that
each individual need to perform fewer smaller and simpler tasks, which have
the advantage of promoting proficiency and the need of less transfer time
between tasks, but also the disadvantage of dissatisfaction associated to
boredom. 

Ferber on Organisations

% >>>
\section{Belief Bases} % <<<

In most agent-oriented programming languages, agents maintain a
\emph{belief base}.  The operations available to the agent are
\textit{query} and \textit{adopt}.  A query asks the belief base which
beliefs that follow a certain pattern it holds.  The adopt operation
changes the state of the belief base by adding and possibly removing
beliefs.  Sometimes, the {\it adopt\/} operation comes in two flavours:
{\it update\/} and {\it revise}.  An update corresponds to a change in the
environment, while a revision is exclusively a mental state change.

\subsection{Beliefs}

In general, beliefs are sentences in some logic.  However, the focus of
this work is on roles and organisations, not on beliefs.  Thus, AF-Raf uses
a very simple language for beliefs\,---\,they are essentially trees whose
nodes are labeled by strings:
\begin{align}
\tau &::= \nu(\tau,\ldots,\tau) && \text{function term} \\
\nu  &::= {\rm string} &&\text{function symbol}
\end{align}
The number of arguments can be any non-negative integer.

\begin{example}
The following are AF-Raf \emph{beliefs}:
\begin{align}
&{\it hasColor}({\it my}({\it car}()), {\it blue}()) \\
&{\it iHave}({\it cat}(), {\it int}({\it 10}()))
\end{align}
Note that any belief must contain a function with $0$~arguments, such as
{\it car}, {\it blue}, {\it cat}, and {\it 10\/} in this example;
otherwise, the belief would not have a finite size.  Note also that
function symbols can represent both values (such as~{\it 10\/}) and typing
information (such as~{\it int\/}).
\eoe
\end{example}

Each function symbol is used with a fixed number of arguments.  For
example, if the function symbol ${\it car}$ is used in one belief with
$0$~arguments in the function term ${\it car}()$, then we expect {\it
car\/} to never have arguments.  We say that each function symbol has an
\emph{arity}, which is~$0$ for {\it car}.  The function terms of arity~$0$,
such as ${\it 10}()$ and ${\it car}()$, are said to be \emph{constants}.

\begin{remark}
Of course, it is important what beliefs mean, not only how they are
represented syntactically.  The meaning of beliefs arises from how beliefs
are used by agents.  We will see later how beliefs trigger actions via
rules, and how beliefs spread through messages.
\eor
\end{remark}

\subsection{Queries}

In general, a query $q$ is a sentence in some logic that determines a
subset of beliefs.  Given a belief base and a query, it is important to be
able to efficiently find the subset of beliefs from the belief base that
satisfy the query.  Again, AF-Raf takes a simple approach, because its
focus is not the belief base.  Each query is term that may contain
variables, which are interpreted as patterns.
\begin{align}
\tau &::= \nu(\tau,\ldots,\tau) && \text{function term} \\
\tau &::= x && \text{variable term} \\
\nu  &::= {\rm string} &&\text{function symbol} \\
x &::= {\rm string} && \text{variable symbol}
\end{align}
The last two grammar rules are the same as for beliefs.
Thus, any belief can be used as a query:  It stands for asking whether the
belief base contains that particular belief.

\begin{example}
The following are AF-Raf \emph{queries}:
\begin{align}
&{\it hasColor}({\it my}({\it car}()), x) \label{eq:query.1} \\
&{\it hasColor}(y, z) \label{eq:query.2}
\end{align}
The variables $x$,~$y$, and~$z$ are easily identifiable, because they are
not followed by parentheses.  Suppose the belief base contains exactly one
belief, namely
\begin{align}
&{\it hasColor}({\it sky}(), {\it blue}()) \label{eq:skyblue}
\end{align}
Belief~\eqref{eq:skyblue} does not match query~\eqref{eq:query.1} but does
match~\eqref{eq:query.2}.  In the latter case, the match is justified by
setting $y$ to be ${\it sky}()$, and setting $z$ to be ${\it blue}()$.
\eoe
\end{example}

The previous example shows how a belief matching a query can be described
by a binding of terms, such as ${\it sky}()$ and ${\it blue}()$, to
variables, such as $y$~and~$z$.  More formally, a \emph{match} is a finite
partial map from the set of variables to the set of ground terms.  We write
$[\tau_1/x_1,\ldots,\tau_n/x_n]$ for the match that binds $x_k$
to~$\tau_k$, for all $1\le k\le n$.  Also, we write
$\tau[\tau_1/x_1,\ldots,\tau_n/x_n]$ for the result of substituting in
parallel $x_k$ with~$\tau_k$, for all $1\le k\le n$.

\begin{example}
Consider the following belief base
\begin{align}
&{\it knows}({\it john}(), {\it john}()) \\
&{\it knows}({\it john}(), {\it laura}())
\end{align}
and the following queries
\begin{align}
&{\it knows}(x, y) \\
&{\it knows}(x, x) \\
&{\it knows}({\it laura}(), {\it john}()) \\
&{\it knows}({\it john}(), {\it laura}())
\end{align}
The results of these queries are, respectively, the following sets of
matchings:
\begin{align}
&\bigl\{ [{\it john}()/x, {\it john}()/y],\;
   [{\it john}()/x,{\it laura}()/y] \bigr\} \\
&\bigl\{ [{\it john}()/x] \bigr\} \\
&\bigl\{\bigr\} \\
&\bigl\{[]\bigr\}
\end{align}
Note that a variable may appear multiple times in a query.  In such a case,
it implicitly requires the corresponding subterms to be equal.  Also note
that the \emph{empty match} differs from \emph{no match}.
\eoe
\end{example}

\todo{Conjunctive queries.}

\subsection{Updates and Revisions}

In general, belief bases have internal and external consistency
requirements.  Internally, beliefs should not contradict each-other.
Externally, beliefs should correspond to reality.

In AF-Raf, the situation is simpler.  There is no other meaning for beliefs
apart from how they affect the behaviour of the agent, through rules.
Thus, it is the agent's responsibility to detect inconsistencies.  In other
words, inconsistencies are detected by programs, not by the programming
language.

\begin{example}
Suppose that a particular agent-oriented program makes the convention that
${\it not}(x)$ means that `I do not hold belief~$x$'.  In this case, the
query ${\it not}(x)\&x$ detects inconsistencies.  The action that the agent
takes when it discovers an inconsistency could be to report an error, but
may be any action at all.
\end{example}

Similarly, the agent (and not the programming language) is responsible with
ensuring that its beliefs are consistent with the environment.

Once semantic concerns are left to the user program, the programming
language AF-Raf is free to adopt simple mechanisms for updating the belief
base.  The belief base is a set of beliefs, and its operations are those of
a set:  ${\bf adopt}(x)$ inserts belief~$x$ into the belief base, and ${\bf
forget}(x)$ removes the belief~$x$ from the belief base.  In case $x$~is
not a belief, ${\bf forget}(x)$ does not modify the belief base.

% >>>
\section{Functional Languages} % <<<

TODO: algebraic data types, type-checking, modules, type classes

% >>>
\section{Multiparty Session Types} % <<<

TODO

% >>>
\section{AgentFactory} % <<<

Agent Factory~\cite{collier2002agent} is an open-source Java-based
development framework that provides support for the development and
deployment of agent-oriented applications.

Agent Factory provides a generic run-time environment for deploying
agent-based systems that is based on the FIPA
standards~\cite{poslad2000fipa}.  Central to this environment is one or
more configurable agent platforms that support the concurrent deployment of
heterogeneous agent types that make up an application, and which can employ
a range of agent architectures and interpreters. In other words the agents
can be categorised in two subgroups: the Application Agents and the System
Agents. The Application Agents implement the application logic. The System
Agents provide the services infrastructure needed to support the deployment
of Application Agents. 

Platform-level resources in the form of platform services are shared
amongst agents. The default platform services are: Agent management
services, which provides support for creating, terminating, suspending and
resuming agents; and local message transport service, which provide an
intra-platform communication channel. Other platform services include the
HTTP message transport service and the directory facilitator service.

Agent Factory also offers monitoring and inspection tools that aid the
developer in debugging their implementations.

Another key feature of Agent Factory is the Common Language Framework,
which represents a collection of pre-written components that facilitates
the design and implementation of diverse Agent Programming Languages in
Agent Factory\null. The Common Language Framework includes a generic logic
framework, a framework for planning and for executing plans, a common API
model based on sensors, actions and modules, an outline grammar and
template compiler implementation based on JavaCC, and a configurable
debugging tool.

The Common Language Framework supports the building of agent interpreters
on top of the Agent Factory core. These interpreters operate within an
agent platform to control the execution of the agent according to an
interpreted Agent Oriented Programming language. This way agents written in
different languages share the same actions, sensors and modules (libraries
or APIs). Actions, sensors and modules are written in Java, and they extend
the agent program so that it can get information about its environment and
act out its intentions. Actions are used to produce changes to the
environment, while sensors generate beliefs, and change the knowledge of
the agent. Each action has an interface that define how it may be invoked
from within the agent program. If a set of actions and sensors are linked
together they can be defined within a module. A module may also provide
resources that are shared amongst several sensors and actions. 

Currently there are four Agent Programming Languages that have been built
using the Common Language Framework:
\begin{enumerate}

\item \textit{AFAPL}, a reimplementation of the original Agent Factory
agent programming language that is based on commitment rules;

\item \textit{AF-AgentSpeak}, an implementation of the AgentSpeak language based on Jason;

\item \textit{AF-TeleoReactive}, an implementation of Nilsson's teleo-reactive
programming model;

\item and our new \textit{AF-Raf}, described in the next section.
\rg{I forgot in which state AF-RAF is. It can't be completed in 4 weeks,
right?}
\end{enumerate}

Agent Factory is fully integrated with Eclipse in a way that simplifies
the task of providing support for new languages and architectures.

For further details on Agent Factory the reader is directed
to~\cite{collier2009modeling}. The Common Language Framework is described
in~\cite{russell2011af}. Also, a discussion on the evolution of Agent Factory since it
was created in the early 1990s can be found in~\cite{muldoon2009towards}.

% >>>
% >>>
\chapter{Usage Scenarios} % <<<

\subsection{Defining core concepts in AF-Raf} % <<<

A number of concepts stand at the foundation of the AF-Raf programming
language. These concepts include: beliefs, rules, actions, sensors, roles
and sessions. They are related to one another and the unique features of
AF-Raf are built upon them. 

Beliefs and rules represent the AF-Raf's core concepts. Beliefs in AF-Raf
are regarded as logical terms and represented in the form of trees of
strings.  Beliefs are grouped together in a belief base that can be
accessed by, and updated by the agent. On the other hand, rules represent a
means for accessing the belief base and also a way of triggering agent
behaviour. A rule has two main components besides a name, which is
optional. These components are a query, and an action. The query puts a
question to the belief base, and if the result matches the query then some
action is triggered.  An action represents the actual agent's behaviour,
which can range from printing something to the console to sending a message
to another agent, creating another agent or even updating the belief base.
Another way to update the belief base is through sensors.

Actions and sensors are pieces of Java code used to extend the AF-Raf
programs. Actions are invoked within rules. There is a number of actions
included in the standard library, which any agent can use, there is also the
option to create new actions. Sensors are run automatically every time
step. Sensors can range from the monitoring of the agent's message inbox to
monitoring changes in the agent's environment.

An operation a specific kind of rule stating that upon receiving a message
of a particular type the agent should reply with a message of a specified
type, which includes the type unit(), and thus returning no message. Even
though operations can be written as rules, using syntactic sugar to
automatise the process of message passing makes answering messages much
easier.

A role's purpose is to group together related behaviour. As stated before
AF-Raf agents interact through message passing. AF-Raf's role concept
reflects this by considering only those kind of behaviours (rules) that
impact other agents through message passing, namely operations. A role is a
set of operation types, acting in a similar way to interfaces in object
oriented programming. When an agent plays a role it needs to give an
implementation to all the operations defined within that role.

Sessions organise the interaction between agents stating the exact order in
which the messages should succeed. A session brings together related roles
and maps the set of operations defined in those roles to a particular
protocol of conversation. A session specifies the agents involved in the
conversation, as well as the roles they play, then provides a list
containing entries of the form: message type followed by the sender agent
and the receiver agent.

AF-Raf statically checks that the type of each call message in a session
corresponds to an operation defined in the receiver's role, and each return
message corresponds to an operation defined in the sender's role.

AF-Raf checks dynamically that the agent playing a role actually implements
the specified types of the operations defined in that role.  For each call
message there's an associated call id which must appear in the return
message. This is a way of keeping track of the message pair associated to
an operation and enable the dynamic check that the message types correspond
to the ones defined inside the role. If the types do not correspond an
error is risen.

Further checks are performed at runtime. Each session has a session id.
Each message has to contain the session id so that it can be associated to
an specific session. This enables the interpreter to monitor that the
messages succeed in the right order.

% >>>


Figure~\ref{fig:AF-Raf-pingpong-role} illustrates an AF-Raf role describing
the ping pong protocol. The code in Figure~\ref{fig:AF-Raf-pingpong-roles}
is a simple implementation of this role.

\rg{What does {\tt (role PingPong=>)} mean? Why is it in parentheses?}
\rg{You should use pattern matching properly, not these weird guards.}
\begin{figure}\footnotesize % <<<
\begin{verbatim}
role PingPong
pingpong :: (role PingPong=>) a -> a
start :: c -> a
\end{verbatim}
\caption{AF-Raf agents playing ping pong}
\label{fig:AF-Raf-pingpong-role}
\end{figure} % >>>

\begin{figure}\footnotesize % <<<
\begin{verbatim}
include stdio.h

Agent P plays PingPong{
  data T = Ping|Pong

  operation pingpong (x : T)
    |x == Ping = sendback(pingpong(Pong))
                 & println("Pong! ")
    |x == Pong = sendback(pingpong(Ping))
                 & println("Ping! ")
 }

  operation start(n){
    if n == agentID(x, y) then send(n,pingpong(Ping))
  }

\end{verbatim}
\caption{AF-Raf agents playing ping pong}
\label{fig:AF-Raf-pingpong-roles}
\end{figure} % >>>

\begin{figure}\footnotesize % <<<
\begin{verbatim}
include stdio.h

Agent P{
  data T = ping | pong

  rule Message (other, pingpong(ping)){
       println("Ping! ");
       send(other, pingpong(ping));
  }

  rule Message (other, pingpong(pong)){
       println("Pong! ");
       send(other, pingpong(pong));
  }

  rule Start (name, addr)){
       println("Ping! ");
       send(agentID(name, addr), pingpong(ping));
  }
}
\end{verbatim}
\caption{desugared pingpong}
\label{fig:desugared-pingpong}
\end{figure} % >>>

\rg{It's ${\it value}:{\it type}$, not ${\it type}:{\it value}$.}
\begin{figure}\footnotesize % <<<
\begin{verbatim}

include stdio.h

Agent P plays PingPong {
  data T = Ping | Pong
  data Mood = Happy | Sad | Neutral

  operation pingpong (x : T, i : int, state : Mood)
    | x == Ping = sendback(pingpong(Pong, i, a))
                  & println("Pong! ")
                  & emotion(state)
    | x == Pong = sendback(pingpong(Ping, i, a))
                  & println("Ping! ")
                  & emotion(state)
        where a = if (i mod 10 == 0) then change_emotion(state)
                                     else state
 }

  operation start(n){
    if n == agentID(x, y) then send(n,pingpong(Ping, 1, Happy))
  }
  operation emotion(Mood: emotional_state){
    | emotional_state == Happy = println(a)
    | otherwise = println(b)
      where a =  "Somebody wants to play!"
            b = "I'm so tired..."
 }
 operation change-emotion(Mood: emotional_state){
   | emotional_state == Happy = Neutral
   | emotional_state ==  Sad = Happy
   | emotional_state == Neutral = Sad
 }
\end{verbatim}
\caption{AF-Raf agents playing ping pong}
\label{fig:AF-Raf-constraint-pingpong}
\end{figure} % >>>

The code in Figure~\ref{fig:AF-Raf-constraint-pingpong} illustrates a
slightly more complex AF-Raf agent implementing the PingPong role. In
addition to the basic functionality illustrated above it has some
constraints that depend on the number of communication steps carried out by
the agents.


\subsection{Haskell Type Classes}

This section reviews Haskell type classes, because they later inspire our
notion of `role', and Haskell modules, so that it is clear they are very
different from type classes. We use sets and equality as examples because
we assume all readers are familiar with these basic mathematical concepts.
\rg{Well, in a thesis you can afford the space to explain even basic concepts.}

% modules
%  - small example
%  - information hiding and encapsulation
%    (exact impl may change; but it is ONE)
%  - separate compilation
%  - analogy with Java classes

Haskell modules are often used to implement abstract data types such as
sets.  To illustrate the main features of modules in little space, the code
in Figure~\ref{fig:haskell} is contrived.  The module \textit{Set} contains
the type~$T$ and the functions \textit{add}, \textit{has}, and
\textit{sub}. The \textbf{module} line hides \textit{sub} by not mentioning
it. The names and types of the exported functions \textit{add} and
\textit{has} are visible from outside the module, but their
implementations, which are to the right of~$=$, are hidden.  Similarly, the
type name~$T$ is visible from outside, but the value constructor~$V$ is
not. For example, the set $\{1,2\}$ may be represented by the value
$V[2,1,2]$, but this is not known to the users of the module \textit{Set}.
The names and types visible from outside constitute the module's
\emph{interface}.

\begin{figure}\footnotesize % <<<
\begin{verbatim}
-- built-in and standard library
class Eq b where
  eq :: b -> b -> Bool
instance Eq Int where ...
elem x [] = False
elem x (y:ys) = eq x y || elem x ys
all p [] = True
all p (x:xs) = p x && all p xs

-- file set.hs
module Set (T, add, has) where
  data T a = V [a]
  add (V s) x = V (x:s)
  has (V s) x = elem x s
  sub (V s) t = all (has t) s

  instance Eq a => Eq (T a) where
    eq s t = sub s t && sub t s
\end{verbatim}
\caption{Haskell type class \textit{Eq} and module \textit{Set}}
\label{fig:haskell}
\end{figure} % >>>

% type classes
%  - continue example
%  - ad-hoc polymorphism: multiple implementations with the same interface
%  - analogy with Java interfaces

The type class \textit{Eq} contains types whose values can be compared for
equality. To make a type belong to the class \textit{Eq} one must write an
instance declaration that provides an implementation for a function
named~$eq$. The \textbf{instance} declaration in module \textit{Set} says
that the type constructor~$T$ transforms members of \textit{Eq} into
members of \textit{Eq}. For example, $T(T\,\mathit{Int})$ is in \textit{Eq}
because \textit{Int} is in~\textit{Eq}.

In general, modules are responsible with information
hiding~\cite{DBLP:journals/cacm/Parnas72a} and encapsulation.  On the other
hand, type classes are an elegant mechanism to provide ad-hoc polymorphism,
also known as overloading~\cite{DBLP:conf/popl/WadlerB89}: The same name
refers to different implementations depending on the context.  Just as
Haskell type classes are different from Haskell modules, the roles we
introduce later are different from existing 2APL
modules~\cite{dblp:conf/prima/dastanims08}.

\subsection{Session Types}

\section{Literature Review}

MD Travers, 1996, Programming with agents: xenia.media.mit.edu/~mt/thesis/mt-thesis-Contents.html

% >>>
\chapter{Usage Scenarios} % <<<

Figure~\ref{fig:AF-Raf-pingpong-role} illustrates an AF-Raf role describing
the ping pong protocol. The code in Figure~\ref{fig:AF-Raf-pingpong-roles}
is a simple implementation of this role.

\begin{figure}\footnotesize % <<<
\begin{verbatim}
role PingPong
pingpong :: (role PingPong=>) a -> a
start :: c -> a
\end{verbatim}
\caption{AF-Raf agents playing ping pong}
\label{fig:AF-Raf-pingpong-role}
\end{figure} % >>>

\begin{figure}\footnotesize % <<<
\begin{verbatim}
include stdio.h

Agent P plays PingPong{
  data T = Ping|Pong
  
  operation pingpong (x:T)
    |x == Ping = sendback(pingpong(Pong)) 
                 & println("Pong! ") 
    |x == Pong = sendback(pingpong(Ping)) 
                 & println("Ping! ") 
 }

  operation start(n){
    if \n = agentID(x, y) then send(n, pingpong(Ping))
  }  
 
\end{verbatim}
\caption{AF-Raf agents playing ping pong}
\label{fig:AF-Raf-pingpong-roles}
\end{figure} % >>>

\begin{figure}\footnotesize % <<<
\begin{verbatim}

include stdio.h

Agent P plays PingPong{
  data T = Ping|Pong
  data Mood = Happy|Sad|Neutral
  
  operation pingpong (x:T, i:int, state:Mood)
    |x == Ping = sendback(pingpong(Pong, i, a)) 
                 & println("Pong! ") 
                 & emotion(state)
    |x == Pong = sendback(pingpong(Ping, i, a)) 
                 & println("Ping! ") 
                 & emotion(state)
        where a = if (i mod 10 == 0) then change_emotion(state) 
                                     else state
 }

  operation start(n){
    if n == agentID(x, y) then send(n,pingpong(Ping, 1, Happy))
  }  
  operation emotion(emotional_state:Mood){
    | emotional_state == Happy = println(a)
    | otherwise = println(b)
      where a =  "Somebody wants to play!"
            b = "I'm so tired..."               
 }
 operation change-emotion(emotional_state:Mood){
   | emotional_state == Happy = Neutral
   | emotional_state ==  Sad = Happy
   | emotional_state == Neutral = Sad
 }
\end{verbatim}
\caption{AF-Raf agents playing ping pong}
\label{fig:AF-Raf-constraint-pingpong}
\end{figure} % >>>

The code in Figure~\ref{fig:AF-Raf-constraint-pingpong} illustrates a
slightly more complex AF-Raf agent implementing the PingPong role. In
addition to the basic functionality illustrated above it has some
constraints that depend on the number of communication steps carried out by
the agents.


\todo{In the code illustrated in Figure~\ref{fig:AF-Raf-constraint-pingpong} I wanted
to have an emotional\_state for each agent instead of an emotional\_state
for their relationship, but I was not able to figure out how to do it
without using a global variable.}

The code in Figure~\ref{fig:AF-Raf-no-roles} illustrates a simple AF-Raf
agent that models a monitor/monitoring agent, using only rules.

\begin{figure}\footnotesize % <<<
\begin{verbatim}
include stdio

rule State(initialized()) & Name(n) {
      println("hello from " + n);
}

rule Monitoring(name, addr) {
      println("ask " + name + " for status");
      send(agentID(name, addr), request(status()));
}

rule Message(other, status(alive())) {
      println("OK, ask again.");
      send(other, request(status()));
}

rule Message(other, status()) {
      println("Oh, someone wants me alive!");
      send(other, inform(status(alive())));
}
\end{verbatim}
\caption{The code of a simple AF-Raf agent}
\label{fig:AF-Raf-no-roles}
\end{figure} % >>>


% >>>
\chapter{Language Definition}\label{ch:method} % <<<

\section{AF-Raf Syntax} % <<<

The purpose of the abstract grammar is to express the general structure of a
programming language as concisely as possible. AF-Raf's abstract grammar:
\rg{You should put most code in figures or, at least, in smaller fonts. The
typical way these things are presented is (1)~one figure with the whole
grammar in small fonts, possibly simplified compared to the real
implementation, and (2)~a few paragraphs commenting the figure. Some
readers look only at the figure, some read only the text: the idea is to
give each what they prefer.}

\begin{verbatim}
ActionData =
  Function function,
  String javaClass;

QualifiedId =
  QualifiedId path,
  String id;

Rule =
  String name,
  IFormula condition,
  BlockStep statement;
  
NamedBindings =
  String name,
  Bindings bindings;

Contract =
  enum(ContractType: pre, post, fail) type,
  IFormula condition;

Plan =
  Function signature,
  ImmutableList<Contract> contract,
  IPlanStep body;
\end{verbatim}

AF-Raf syntax is defined using the Extended Backus-Naur Form notation. The
grammar for top level structures is as follows:

\begin{verbatim}
script: directive* EOF;
\end{verbatim}
A script is composed of a number of directives followed by the EOF symbol.

\begin{verbatim}
directive: include | java_binding | plan | rule;
\end{verbatim}
A directive is either an include, a java binding , a plan, or a rule.

\begin{verbatim}
include: 'include' a=qualified_id;
\end{verbatim}
The include directive must contain the keyword "include" followed by a
qualified id which represents a reference to a file (the package path, file
name and its extension).

\begin{verbatim}
java_binding: action | sensor;
\end{verbatim}
A java binding could be either an action or a sensor.

\begin{verbatim}
plan: 'plan' a=function '{' b=contract c=statement '}';
\end{verbatim}
A plan is composed of a function followed by a contract and a statement.

\begin{verbatim}
rule: a='rule' b=formula '{' c=statement '}';
\end{verbatim}
A rule is a formula that represents a condition followed by a statement
to be executed.

\begin{verbatim}
action: 'action' a=function '=' b=qualified_id ';';
\end{verbatim}
An action is defined as a function to which is assigned a reference to a file.

\begin{verbatim}
sensor: 'sensor' a=qualified_id ';';
\end{verbatim}
A sensor is a reference to a file.

\begin{verbatim}
contract: (a=contract_type b=formula ';' )*;
\end{verbatim}
A contract is a contract type followed by a formula.


Grammar for formulas and terms:
\begin{verbatim}

formula:
  a=formula_a 
  ('=>' b=formula_a)?;
\end{verbatim}

\begin{verbatim}
formula_a:
  a=atom_formula  
  (b=('&' | '|') c=atom_formula)*;
\end{verbatim}
A formula$\_$a is either an atom formula, a conjunction of atom formulas or a
disjunction of atom formulas.

\begin{verbatim}
atom_formula returns [IFormula v]:
     a=predicate 
  | '!' b=atom_formula 
  | '(' c=formula ')';
\end{verbatim}
An atom formula is either a predicate, a negated atom formula or a formula
enclosed in brackets.

\begin{verbatim}
predicate:
    a=term b=pred_op c=term  
  | d=UID '(' e=term_list? ')';
\end{verbatim}
A predicate is either a term followed by a predicate operation and then by another
term or a upper case starting word followed by zero or one term lists
enclosed in brackets.

\begin{verbatim}
term:
    a=term_a   
    (b=add_op c=term_a)*;

\end{verbatim}
A term is a term$\_$a to which add$\_$op and another term$\_$ can be added zero or
more times. 

\begin{verbatim}
term_a:
    a=atom_term  
    (b=mul_op c=atom_term)*;
\end{verbatim}
A term$\_$a is an atom term to which mul$\_$op and another atom
term can be added zero or more times.

\begin{verbatim}
atom_term:
    '(' a=term ')' 
  | b=literal 
  | c=LID 
  | d=function;
\end{verbatim}
An atom term is either a term enclosed in brackets, a literal, a lower case
starting word or a function.

\begin{verbatim}
function : a=LID '(' b=term_list? ')';
\end{verbatim}
A function is a lower case starting word followed by zero or one term lists
enclosed in brackets.

\begin{verbatim}
term_list:
  a=term 
  (',' b=term)*;
\end{verbatim}
A term$\_$list is a term followed by zero or more terms that are delimited
by a comma.

\begin{verbatim}
pred_op: (a=eq_op | a=cmp_op);
\end{verbatim}
A pred$\_$op is either a eq$\_$op or a cmp$\_$op operation.

\begin{verbatim}
eq_op: (a='==' | a='!=');
\end{verbatim}
An eq$\_$op is comparing either for equality or for non equality.

\begin{verbatim}
cmp_op: (a='<' | a='>');
\end{verbatim}
An cmp$\_$op is comparing either for greater or for lesser.

\begin{verbatim}
add_op: (a='+' | a='-');
\end{verbatim}
An add$\_$op is either the addition or subtraction operation.

\begin{verbatim}
mul_op: (a='*' | a='/' | a='%');
\end{verbatim}
A mul$\_$op is either the multiplication, division or modulo operation.


\begin{verbatim}
unary_op: (a='!' | a='-');
\end{verbatim}
A unary$\_$op is either the logical or arithmetic negation.

Grammar for statements:
\begin{verbatim}
statement:  (a=atom_statement ';')*;
\end{verbatim}
A statement is a composed of zero or more atom statements.

\begin{verbatim}
atom_statement:
    ('{' a=statement '}'
  | a=assignment
  | a=while_statement
  | a=foreach
  | a=call
  | a=update_belief
  | a=if_statement);

\end{verbatim}
An atom statement is either a statement inside curly brackets, an
assignment, a while statement, a foreach, a call, an update belief or an if
statement.

\begin{verbatim}
assignment: 
  a=LID '=' (b=function | b=list_comprehension);
\end{verbatim}
An assignment statement is composed of a lower letter word equal sign and
either a function or a list comprehension.

\begin{verbatim}
while_statement: 
  'while' a=formula '{' b=statement '}';
\end{verbatim}
A while$\_$statement is composed of the "while" keyword, a formula and a
statement enclosed in curly brackets.

\begin{verbatim}
foreach: 'foreach' a=formula '{' b=statement '}';
\end{verbatim}
A foreach statement is composed of the "foreach" keyword, a formula,
followed by a statement enclosed in curly brackets.

\begin{verbatim}
update_belief: 
  (a='+' | a='-') b=predicate;
\end{verbatim}
The update$\_$ belief statement has the form of either a plus sign or a
minus sign followed by a predicate.

\begin{verbatim}
call: a=function;
\end{verbatim}
A call statement is represented by a function.

\begin{verbatim}
if_statement: 
  'if' a=formula '{' b=statement '}' ('else' '{' c=statement '}')?;
\end{verbatim}
An if$\_$statement is composed of the "if" keyword, a formula, a statement
enclosed in curly brackets and zero or one "else" keyword along with a
statement in curly brackets.

\begin{verbatim}
list_comprehension: 
  '[' term '|' formula ']';
\end{verbatim}
A list$\_$comprehension is composed of a term, and a formula contained
within square brackets.

Lexer:

\begin{verbatim}
qualified_id:
  (t=id '.')* t=id;
\end{verbatim}
A qualified$\_$id is represented zero or more pairs of ids, either LID or
UID, and dots, followed by an id.

\begin{verbatim}
contract_type:
    (t='pre' | t='post' | t='fail');
\end{verbatim}
A contract type is either the string "pre", "post", or "fail".

\begin{verbatim}
literal:
    t=STRING 
  | t=INT;
\end{verbatim}
A literal is either a string or an int.

\begin{verbatim}
id: LID | UID;
\end{verbatim}
An id is either a LID or a UID.

\begin{verbatim}
INT: '0'..'9'+;
STRING: '"' (~'"' | '\\"')* '"';  
\end{verbatim}


\begin{verbatim}
LID: ('a'..'z')('a'..'z'|'A'..'Z'|'0'..'9'|'$')*;
UID: ('A'..'Z')('a'..'z'|'A'..'Z'|'0'..'9'|'$')*;
\end{verbatim}

\begin{verbatim}
WS:   (' '|'\t'|'\n'|'\r')+;
BLOCK_COMMENT: '/*' ( options : . )* '*/';
LINE_COMMENT: '//' ~('\n'|'\r')* ('\r'|'\n');
\end{verbatim}
% >>>

\section{Operational Semantics} % <<<

An AF-Raf agent program interpretation starts with the execute() method. It
first gets all the messages from the inbox, and for each message adds a
corresponding beliefs to the belief base. After that for each rule calls
the handlerule() method. For each rule constructs a query to the belief
base based on the rules condition. Then applies each successful set of
bindings to the statement of the rule, includes the rule in the list of
last fired rules and execute the statement.
% >>>

\section{The AF-Raf programming Language} % <<<

AF-Raf is a new agent oriented programming language I specifically
developed to incorporate the support for organising multiagent
systems at the language level.

The main reason for choosing to build it from scratch is simplicity.  AF-Raf
has a very simple syntax, which makes easier the addition of new functionality
without making it too difficult to use.

One important feature of the AF-Raf programming language is its integration
with the AgentFactory development framework, which provides support for the
development and deployment of agent-based systems.

The main particularity of AF-Raf, that makes it unique among agent oriented
programming languages is that, even though it is built upon the agent
oriented conceptual framework, it also draws inspiration from functional
languages.

AF-Raf has two fundamental components, a \textit{belief base}
and a \textit{rule base}. The belief base models the agent's view of the
current state of its environment and the rule base models the agent's
behaviour.

Beliefs are terms, where a term denotes an expression that can be obtained from
either a constant symbol, a variable or a function symbol. Rules are
represented by a name (optional), a query and an action.  The code in
Figure~\ref{fig:AF-Raf} illustrates an AF-Raf agent.

\begin{figure}\footnotesize % <<<
\begin{verbatim}
include stdio

rule State(initialized()) & Name(n) {
      println("hello from " + n);
}

rule Monitoring(name, addr) {
      println("ask " + name + " for status");
      send(agentID(name, addr), request(status()));
}

rule Message(other, status(alive())) {
      println("OK, ask again.");
      send(other, request(status()));
}

rule Message(other, status()) {
      println("Oh, someone wants me alive!");
      send(other, inform(status(alive())));
}
\end{verbatim}
\caption{The code of an AF-Raf agent}
\label{fig:AF-Raf}
\end{figure} % >>>

The rules are evaluated at each time-step. The first stage of evaluating a
rule is to evaluate the query on the current belief base. The result is a
set of query results. \rg{A result is a set of results? Empty set is
special?} If the set is not empty, the action is then evaluated for every
query result. A particular query result says with what term to substitute
each free variable in the action. In other words, a query result is a set
of bindings that covers all the free variable in the action (of the rule).
The first step of evaluating the action is to apply these substitutions.
The next step is to execute it.

An action is either a simple action or a composed action. Executing a
simple action means executing a piece of associated Java code. Examples of
simple actions include sending a message (\textit{send}), logging a string
(\textit{println}), and adopting a belief (\textit{adopt}).  Composed
actions, also referred to as plans, include sequence and while loops.

Sensors are pieces of Java code that are run at each time-step. They are
typically used to update the belief base according to the changes in the
environment. For example, there is a standard sensor (defined in
\texttt{stdio}) that adds a belief $\mathit{Message}(s,c)$ when a message
with content~$c$ is received from sender~$s$. % >>>

\section{Algebraic Data Types and Type Checking} % <<<

\subsection{Algebraic Data Types} % <<<
\subsubsection{Types in AF-Raf}

AF-Raf contributes to the AOP languages domain by being the first agent
oriented programming language to introduce types and type-checking. \rg{I
think this needs to be qualified: surely other languages have things like
integers and strings, which are types.} From a practical point of view, our
effort tries to improve upon the following scenario.

\paragraph{Bad Scenario.}

\rg{Needs a diagram; otherwise, hard to follow.}
Agent~$a$ sends message $\tau_{ab}$ to agent~$b$. Agent~$b$ stores a
subterm~$\tau_b$ of~$\tau_{ab}$ into its belief base. Later, when some
other condition is satisfied, agent~$b$ extracts a subterm~$\tau_{bc}$ of
term~$\tau_b$ and sends it to agent~$c$. Agent~$c$ extracts a
subterm~$\tau_c$ of term~$\tau_{bc}$ and stores it in its belief base.
Later, when some other condition is satisfied, agent~$c$ extracts a
subterm~$\tau$ of~$\tau_c$. Agent~$c$ expects $\tau$ to be an integer
literal, but instead $\tau$ is a string literal. Agent~$c$ notices the
problem, but many things happened since agent~$a$ sent an invalid message.

The goal of AF-Raf's dynamic typing is to notice such errors early.

For this purpose, each agent~$a$ has two attached types. The type $\delta_b(a)$
represents the type of $a$'s beliefs and the type $\delta_m(a)$ represents the
type of messages that $a$ can process. These types are selected when the agent
is created.

Whenever a belief $\tau$ is added to $a$'s belief base, Agent~Factory checks
whether that belief is in the set of terms defined by the $a$'s belief type;
that is, the expression $\tau:\delta_b(a)$ is evaluated.  Whenever a
message~$\tau$ is sent to agent~$a$, the expression $\tau:\delta_m(a)$ is
evaluated, to check whether that message complies to the type of messages that
agent~$a$ can process. In order to send a message to agent~$a$, the other agent
needs the agent identifier of agent~$a$. Agent identifiers typically consist of
a name and an IP address. To support the check for messages we add
$\delta_m(a)$ to the agent identifier of agent~$a$.

\paragraph{Algebraic Data Types, Primitive Types, and Aliases.}

In AF-Raf, a \emph{belief} is a boolean ground term; in AF-Raf, a
\emph{message} is a non-boolean ground term.

Algebraic data types offer an alternative way of defining sets of ground
terms. In multi-sorted predicate logic, the sort~$\sigma$ determines a set
of ground terms, namely those of the form $\nu(*)$, where $\nu$ has a
signature of the form $*\to\sigma$.  For example, the sort \textit{Bool}
determines the set of terms that are formulas.  With algebraic data types,
a type~$\delta$ is defined by a sequence of patterns, each of the form
$\nu(\delta_1,\ldots,\delta_n)$. For example, one could define the types
\textit{nat}, $e$, and~$o$ as follows.
\[\mathbf{type}\,\mathit{nat} =
  \mathit{zero}()
  \mid\mathit{succ}(\mathit{nat})
  \mid\mathit{add}(\mathit{nat},\mathit{nat})\]
\[\mathbf{type}\,e =
  \mathit{zero}()
  \mid\mathit{succ}(o)
  \mid\mathit{add}(e,e)
  \mid\mathit{add}(o,o)\]
\[\mathbf{type}\,o =
  \mathit{succ}(e)
  \mid\mathit{add}(o,e)
  \mid\mathit{add}(e,o)\]

In Agent~Factory, string literals and integer literals are
also terms, and AF-Raf inherits this decision. AF-Raf has
predefined corresponding primitive types \textit{string} and
\textit{integer}. Moreover, any Java type is suitable to be an AF-Raf
primitive type.

Binary operators such as $+$ are also inherited from Agent~Factory. From
the point of view of type-checking, an expressions like $2+3$ is equivalent
to $+(2,3)$. Standard conventions on precedence and associativity are
obeyed.

More interestingly, AF-Raf has built-in the type $\mathit{integer}[\tau]$,
where $\tau$ is a formula that may use the special variable \textbf{this}.
For example, the type \[\mathit{integer}[\mathbf{this}\%2==0]\] defines the
set of ground terms $\{\,\ldots,-4,-2,0,2,4,\ldots\,\}$. Similarly, AF-Raf
has built-in the type $\mathit{string}[\tau]$. For example, the type
\[\mathit{string}[\mathbf{this}\;\mathbf{matches}\;\verb|"[a-z]+"|]\]
defines the set of string literals that match the given regular expression.

Enhanced with algebraic data types, the AF-Raf programming language has
virtually endless possibilities to define new types. The primitive types
are combined using discriminated union and cartesian product in the manner
described above.

To support the interaction with untyped languages, AF-Raf also has built-in
the type \textit{Any}, which defines the set of all ground terms.

Finally, one may define type aliases.
$\mathbf{type}\,\delta=\delta'$

Such aliases are especially useful when $\delta'$ is of the form
$\mathit{integer}[\tau]$ or $\mathit{string}[\tau]$, and $\tau$~is long.
% >>>
\subsection{Type Checking} % <<<
\paragraph{Type Checking.}
By \emph{type-checking} we mean deciding whether a given ground term~$\tau$
belongs to a given type~$\delta$. This is the operation performed, for
example, on the content of a message before sending it. We include here a
reference implementation for type-checking. We use the language OCaml, for
it is terse.

First, we need data structures for representing terms and types. Terms are
either non-primitive (abstract) or primitive (integers or strings).
\begin{verbatim}
    type term =
          | A of string * term list
          | I of int
          | S of string
\end{verbatim}
A non-primitive term has the shape $A(\nu,\Theta)$, where $\nu$~is a
function name and $\Theta$~is a list of terms. A primitive term simply maps
to the primitive types of the language in which the type-checker is
written.

Similarly, types are either abstract or primitive.
\begin{verbatim}
    type type_ =
          | AT of (string * type_ list) list
          | IT of (int -> bool)
          | ST of (string -> bool)
\end{verbatim}
An abstract type is defined by a list of patterns. Primitive types contain the
user-defined predicates. For example, the type
\[\mathit{integer}[\mathbf{this}\%2==0]\] is represented in the type-checker by
\begin{verbatim}
   IT (fun x -> x mod 2 = 0)
\end{verbatim}

Type-checking is then straightforward.
\begin{verbatim}
   let rec check v ts = match v, ts with
     | A (v, vs), AT ts ->
         let f (t, ts) =
           v = t && all2 check vs ts in
         List.exists f ts
     | I v, IT ts -> ts v
     | S v, ST ts -> ts v
     | _ -> false
\end{verbatim}
This code first checks that the term and the type are of the same kind. For
example, it returns false if the term is non-primitive but the type is
primitive. The interesting branch is the first one, which is taken when
both the term and the type are abstract. It checks whether there exists a
pattern (in \verb|ts|) that matches the term with the head~\verb|v| and the
sub-terms~\verb|vs|. The function~\verb|f| processes one pattern with the
head~\verb|t| and the sub-types~\verb|ts|. The heads must match and the
sub-terms must match, respectively, the sub-types. The function \verb|all2|
wraps the standard function \verb|List.for_all2| so that it returns
\verb|false| when the number of sub-terms is different from the number of
sub-types.
\begin{verbatim}
    let all2 f xs ys =
      try List.for_all2 f xs ys
      with Invalid_argument _ -> false
\end{verbatim}

We exhibited an algorithm, hence type-checking is decidable. As it is, the
function \verb|check| takes exponential time in the size of the term.
However, with memoization its complexity is~$O(mn)$, where $m$~is the
size of the term and $n$~is the size of all type definitions.
\rg{Maybe expand a bit here, with some example?}

% >>>
% >>>

\section{Roles and Session Types} % <<<

\subsection{Specifying Roles in AF-Raf} % <<<

The theory of organisations, from economy, studies how formal rules of
interaction enable groups of people to achieve common goals; the theory of
roles, from sociology, studies how individuals fit in multiple informal
groups. Both theories influenced prior attempts to structure agent systems.
Several agent-oriented methodologies and libraries incorporate the concept
of organisation and the concept of role.  However, there is little work on
designing language features with the specific purpose of supporting large
agent systems~\cite{collier2005,DBLP:journals/entcs/BaldoniBT06}. We
approached this language design problem by drawing inspiration from analogies
between agent-oriented programming languages and functional languages. For
concreteness, we focused on 2APL~\cite{DBLP:journals/aamas/Dastani08} and
Haskell~\cite{web:haskell}.

Haskell and 2APL are very different languages. We did not try to establish
any sort of formal connection between them, but rather to identify fruitful
high-level similarities. The task was akin trying to draw the Earth's
surface on paper---much easier to do locally than globally. We proceeded,
therefore, by finding a contact point, seeing what it tells about its
surroundings, and then repeating.

\paragraph{Functions as Messages} % <<<

A function call $f\,x$ is evaluated by `sending'~$x$ to $f$'s body,
evaluating the body, and then receiving the result. The process is
analogous to the exchange of a pair of messages between two agents. For
example, the role \textit{Calculator} could be specified as follows.
\begin{verbatim}
role Num a => Calculator a
  eval :: Expr a -> a
\end{verbatim}
An agent that plays the role $\mathit{Calculator}\,\mathit{Int}$ knows
how to compute expressions such as $(3+3)\times5$, given another agent
that plays the role $\mathit{Num}\,\mathit{Int}$.
\begin{verbatim}
role Num a
  add :: Pair a -> a
  multiply :: Pair a -> a
\end{verbatim}
An agent that plays the role $\mathit{Num}\,\mathit{Int}$ knows how to
compute basic operations on integers, such as $3+3$ and $6\times5$. The
types \textit{Expr} and \textit{Pair} constrain the content of messages.
\begin{verbatim}
data Expr a = Times (Expr a) (Expr a)
            | Plus (Expr a) (Expr a)
            | Ct a
data Pair a = MkPair a a
\end{verbatim}
Given a user agent~$u$, an agent~$c$ that plays
$\mathit{Calculator}\,\mathit{Int}$, and an agent~$n$ that plays
$\mathit{Num}\,\mathit{Int}$, the following is a possible exchange of
messages.\\ \\
$u\to c :
  \mathit{eval}(\mathit{call}(n), \mathit{Times}(
    \mathit{Plus}(\mathit{Ct}(3),\mathit{Ct}(3)),\mathit{Ct}(5)))\\
c\to n : \mathit{add}(\mathit{call}(), \mathit{MkPair}(3, 3))\\
n\to c : \mathit{add}(\mathit{return}(), 6)\\
c\to n : \mathit{multiply}(\mathit{call}(), \mathit{MkPair}(6, 5))\\
n\to c : \mathit{multiply}(\mathit{return}(), 30)\\
c\to u : \mathit{eval}(\mathit{return}(), 30)$\\

In general, $f::a\to b$ says that the agent understands messages of the
form $f(\mathit{call}(\alpha_1,\ldots,\alpha_n),x)$ and eventually replies
to each of them with a message of the form $f(\mathit{return}(),y)$. Here,
$\alpha_1$, \dots,~$\alpha_n$ are (addresses of) other agents, $x$~is a
value of type~$a$, and $y$~is a value of type~$b$.

The analogy so far is already fruitful. The content of 2APL messages is a
(ground) term or an atomic formula. Since 2APL is built on top
JADE~\cite{DBLP:books/sp/map2005/BellifemineBCP05}, the message content may
also be declared as part of an ontology. However, if we would show the JADE
ontology for arithmetic expressions we would run over the page limit.
Contrast with the three short lines used here to define $\mathit{Expr}\,a$.
The definition is not only short and readable, but also polymorphic in the
type~$a$ of the constants, and rooted in the theory of algebraic data types
(see, for example, \cite{DBLP:conf/ctcs/Hagino87}).

\begin{figure}\footnotesize % <<<
\begin{verbatim}
agent foo plays Calculator Int(n)
  R-rules:
    eval(Ct(x)) <- x
    eval(Times(x, y)) <-
      n.multiply(MkPair(this.eval(x), this.eval(y)))
    eval(Plus(x, y)) <-
      n.add(MkPair(this.eval(x), this.eval(y)))
\end{verbatim}
\caption{Implementing a role in 2APL}\label{fig:roleimpl2APL}
\end{figure} % >>>

The analogy is not perfect. The earlier declaration for the role
$\mathit{Calculator}\,a$ is superficially similar to the following type
class declaration.
\begin{verbatim}
class Num a => Calculator a
  eval :: Expr a -> a
\end{verbatim}
This declaration reads ``a type~$a$ that is a member of the class
\textit{Num} is also a member of class \textit{Calculator} provided there
exist a function \textit{eval} with the proper type.'' In contrast, the
earlier role declaration reads ``an \emph{unnamed} agent plays role
$\mathit{Calculator}\,a$ if it answers to messages
$\mathit{eval}(\mathit{call}(n),\ldots)$ by messages
$\mathit{eval}(\mathit{return}(),\ldots)$, where $n$~is an agent that plays
$\mathit{Num}\,a$.'' Here $a$~is a type variable.  When implementing a role
the agent must be named, as seen in Figure~\ref{fig:roleimpl2APL}. Because
\textit{foo} plays $\mathit{Calculator}\,\mathit{Int}$, the agent
interpreter creates a goal $\mathit{eval}(m,\mathit{call}(n),x)$ for all
messages with shape $\mathit{eval}(\mathit{call}(n),x)$ that come from some
agent~$m$.  One could handle these goals using 2APL's PG-rules.
\begin{verbatim}
eval(m, call(n), Ct(x)) <- true |
  send(m, role, eval(return(), x))
\end{verbatim}
The first R-rule in Figure~\ref{fig:roleimpl2APL} does exactly the same,
but is more compact. The other two R-rules, however, are much more
cumbersome to simulate with the other kinds of rules. The main reason is
that the notation $n.\mathit{add}(x)$ hides sending a message
$\mathit{add}(\mathit{call}(),x)$ to agent~$n$, waiting for a reply
$\mathit{add}(\mathit{return}(),y)$, and extracting~$y$. The (goal) query
of an R-rule may only be an atom; the right side of an R-rule is an
expression that is evaluated as described and whose result is sent as a
message.  This is a rough and informal sketch of the intended semantics
that needs to be made precise.

Note that two agents \textit{foo} and \textit{bar} may be instances of the
same 2APL module, yet only \textit{foo} plays the role
$\mathit{Calculator}\,\mathit{Int}$. Also, note that an agent may be
declared as playing a role without having access to its implementation. In
fact, it may be that the basic behaviour of the agent is programmed in a
different language than 2APL. Such flexibility helps code reuse.

In summary, the vague and informal intuition that a function is like a pair
of messages, one carrying the arguments and one carrying the result, led us
to two interesting observations. First, algebraic data types are convenient
for describing the content of messages. We expect to see fewer runtime
errors once messages are typed. Second, we developed a notion of role in
the context of the 2APL language. These roles have certain similarities
with existing 2APL modules and with Java interfaces, but are nevertheless
distinct concepts.
% >>>

\subsection{Specifying AF-Raf Sessions} % <<<

Agents play roles and we wrote roles much like Haskell type
classes, so it would seem that the analogue of Haskell types are
agents. A Haskell type class is a set of Haskell types; a role is a
set of agents that play the role. I would like to explore where
does the intuition ``types as agents'' lead.

\begin{figure}\footnotesize % <<<
\begin{verbatim}
session ComputeBasicOperation(a, b)
  a -> b: Pair Int
  b -> a: Int
session ComputeExpression(a, b, c)
  c -> a: Expr Int
  repeat ComputeBasicOperation(a, b)
  a -> c: Int
\end{verbatim}
\caption{Sessions for AF-Raf}\label{fig:sessions}
\end{figure} % >>>

{\def\l#1->#2:#3<#4>{\mathtt{#1}\to\mathtt{#2}:#3\langle\mathsf{#4}\rangle}
We read $f::a\to b$ as ``message $f$ is sent by agent~$a$ to agent~$b$.'' A
type class lists several function signatures, so its natural analogue is a
list of messages together with their endpoints. It turns out that such a
list is very similar to the global types that describe multiparty sessions
in the context of $\pi$-calculus. Here is an example of such a type from
Honda et al.~\cite{dblp:conf/popl/hondayc08}:\\
$\mu\mathbf{t}.$
  $\l DP->K:d<bool>. $\\
  $\l KP->K:k<bool>. $\\
  $\l K->C:c<bool>.\mathbf{t}$

This type means that process \texttt{K} receives two booleans, one from
\texttt{DP} through channel~$d$ and one from \texttt{KP} through channel~$k$,
then sends a boolean to~\texttt{C} through channel~$c$, and the whole process
repeats. The main differences are that we have agents, rather than processes,
and there are no named channels. We would therefore like to write code like
that in Figure~\ref{fig:sessions}.  These sessions are a global description of
the messages that should flow within an agent system. When we project
$\mathit{ComputeExpression}(a,b,c)$ on agent~$a$ we obtain the role
$\mathit{Calculator}\,\mathit{Int}$ from the previous section.}

In agent-oriented methodologies it is standard to say that ``an agent plays
a role within an organisation,'' and therefore organisations are somehow
collections of interacting roles, just as the sessions above are in a way
putting together interacting roles. Similarly, in multiparty session types
there is a notion of projecting global types onto local types. The
essential advantage of session types is that the projection can be done
automatically. By imitating session types, we hope that it will be possible
to at least check automatically that the projection of a certain session on
a certain agent matches a certain role, which the agent implements.

In summary, the vague and informal intuition that a Haskell type is
sometimes like an agent led us to the proposal of specifying global
interactions in agent-oriented programming languages in terms of sessions.
Moreover, it seems reasonable to expect that a precise link between these
session and the roles proposed in the previous section can be found.
% >>>
\subsection{Future Work} %<<< %>>>
% >>>
% >>>

% >>>
\chapter{Related Work} % <<<


Following the research presented in this thesis, Ricci  and Santi developed
a new programming language, simpAL, to support types and type
checking~\cite{}. SimpAl draws inspiration from the Agent and Artifacts
model~\cite{} and from the Jason programming language, which is based on
the Belief, Desire, Intention model. SimpAL is conceived as an extension to
the Java object oriented programming language with a separate agent
abstraction layer. 

Even though this language is very different from AF-Raf, there are a
number of overlapping concepts. SimpAL imports a social view of computation
where agents playing different roles constitute an organisation, and work
within a shared environment. The main building blocks of this model are
agents, the autonomous components, and artifacts, the environmental
components that provide functionality or services. The agent has a belief
base, some tasks to perform and a set of plans to utilise in order to
acomplish the tasks. SimpAl roles are very similar to AF-Raf roles in that
they constitute a set of tasks types, where tasks are the analogous to the
AF-Raf operations. 

The roles are organised in a slightly different manner compared to the
AF-Raf's session type model, which can be seen as a kind of protocol
prescribing the agent communication. In simpAL organisation models are used
to define organisation types, that bring together related roles and
artifact in coherent units named workspaces. Organisation types are
implemented by concrete organisations. SimpAL organisation types do not put
any constraint on the order in which interactions between agents occur, as
AF-Raf session types do, instead they simply group together related roles
and artifacts working in a similar way to the object oriented programming
interfaces.

A number of static type checks are performed. At the role level it is
checked that for each task type there exists at least one plan, and for
each plan it's checked that the type of the sent messages are only the ones
defined in the task type. Also it's checked that the assignment of tasks
corresponds to the task types defined in the role, and that the types of
the messages sent to an agent correspond to that the agent can understand. 

Errors about beliefs that are checked include finding, inside the plans,
beliefs that are not declared, and beliefs that are assigned with
expressions of the wrong type.

Similar checks are performed at the environment level. The usage interface
represents the type of artifact, and contains the observable properties and
the operations provided by the artifact. Artifact template is the actual
artifact implementation. On the agent side are checked errors regarding
artifact operations and its observable state. For each action in the plan
there must be a matching operation in the artifact's interface.  Likewise,
for each update belief statement regarding an artifact property there must
exist a matching observable property in the usage interface. On the
environment side is checked that the artifact templates match the
corresponding usage interfaces. First, checks are performed to ascertain
that for each operation declared in the interface there exists an
implementation in the template, also for any of the observable properties
in the template there exists a declaration in the corresponding interface
with a compatible type.

At the organisation level it is checked that each workspace, artifact, and
agent types declared in an organisational model is actually implemented in
the implementation of the organisation. 
\\~\\

Subsequent to my proposal to integrate session types with agent programming
languages, global session types were exploited further in the context of
multiagent systems~\cite{} to specify multiparty interactions and verify
their correctness. They were used for automatic generation of
self-monitoring agent systems implemented in Jason. The solution suggested
was to generate a monitor agent that checks at runtime that the ongoing
conversation is correct conform to the global session type. In this
context, global session types are viewed as states, on which several
transition steps are possible. Transitions occur with each successfully sent
message.

In order to be able to generate the agent monitor, the developer needs to
provide Prolog rules to define global session types, to specify possible
transitions to different states upon message sending, and to specify the
message content types. As well, a number of changes to the code of the
participating agents need to be done to support the integration with the
monitor agent. 

There's only one monitor agent that keeps track of all messages and checks
if there exists a new state that can be reached from the current state. If
the transition is possible the monitor agent allows the sending action by
acknowledging it to the sending agent. If such a transition is not
possible the protocol fails and there's no possibility of self recovery.
The developer has to change either the agent code or the global session
type's specification in order to fix the error. 
\\~\\

A role-based approach to reuse in agent oriented programming. Rem 2005.
\\~\\

Rope: role oriented programming environment for multiagent systems. Becht
1999
\\~\\

Roles and norms for programming agent organisations. Tinnemeier 2009
\\~\\

% >>>
\chapter{Conclusions}\label{ch:conc} % <<<

Starting from high-level similarities between certain aspects of an
agent-oriented programming language (2APL) and a functional programming
language (Haskell), we described three new features for the former:
(1)~algebraic data types, which constrain the content of messages,
(2)~roles, which constrain how particular agents interact, and
(3)~sessions, which describe slices of the global interactions in the agent
system. Together, these \emph{language features} support organisational
concepts, which are so far discussed mostly in the literature on
agent-oriented methodologies and frameworks.

The aim is to provide programmers with a wider set of options at their disposal
for structuring large agent systems. For example, they can use existing
methodologies during the design phase and they can use a mixture of our
proposed language features and existing organisational frameworks during the
implementation phase. First-class language support has at least two
advantages over organisational frameworks. First, implementations tend to be
shorter and more readable. Second, implementations have stronger correctness
guarantees because of the extra type-checking. On the other hand,
organisational frameworks may be preferred when one needs to interact with
legacy code.

We created a new agent oriented programming language, AF-Raf, based on the
existing Agent Factory framework, and started to implement the innovative
features we have identified. AF-Raf has already types, including algebraic
data types to constrain the content of the messages, and type checking. At
the moment I am working on the implementation of roles in AF-Raf, and
subsequently we will move to the implementation of sessions. By the end of the
year we will use a number of case studies to test it, then incorporate the
results, and submit a paper to be published in the AAMAS conference. We will
have to further formalize and evaluate the AF-Raf programming language while
writing up the PhD thesis. \rg{This is a bit too self-referential, no?}

% >>>
\bibliographystyle{plain}
\bibliography{thesis}
\appendix
\chapter{Old Preliminaries} % <<<

\section{Problem Statement}
\section{Conceptual Framework}

\todo{What are Multi Agent Systems(MAS)? interacting intelligent agents within
an environment.}

\rg{I don't understand these TODO notes: The purpose of preliminaries is to
(1)~remind the reader some standard technical knowledge and (2)~establish
notations.  Things like `how cool and useful agents are' belong to the
introduction.}
\todo{advantages of MAS approach}

\todo{Practical applications: online trading, social simulations, wireless
communication}

\todo{frameworks, development tools}

\todo{agent oriented programming}


\subsection{The Agent Factory Framework} \label{sec:af}

\subsection{Multi-Sorted Predicate Logic} \label{sec:multi-sorted}

Our starting point is the observation that most agent oriented programming
languages use first order logic, more specifically predicate logic terms,
to represent beliefs and messages. As a consequence we look at how the
introduction of types is managed in mathematical logic, and recall basic
notions necessary to our understanding. We also introduce notational
conventions used in AF-Raf.  Moreover, although these notions are simple,
their definitions in literature tend to have subtle but important
differences.
\rg{Most of this section does not belong to preliminaries, as it is not that
standard. I would put it somewhere between examples and reference.}

A \emph{term} is a variable, or a function applied to other terms.
\begin{align}
\mathit{Term}\quad\tau &::= \omega \mid \phi \\
\mathit{Variable}\quad\omega &::= \nu \\
\mathit{Function}\quad\phi &::= \nu(\tau_1,\ldots,\tau_n) \\
\mathit{Name}\quad\nu
\end{align}
In AF-Raf, term names are strings.  Because term names uniquely identify a
variable or a function we will say ``the function~$\nu$'' rather than ``the
function with name~$\nu$.'' A term not containing variables is said to be
\emph{ground}.

\begin{remark}
Ground terms are essentially trees of strings.
\end{remark}

A multi-sorted logic has a set~$S$ of sorts.  We use the letter~$\sigma$ to
denote sorts.
\begin{align}
\sigma, \sigma_1, \sigma_2, \sigma_3, \ldots &\in S
\end{align}
Each function~$\nu$ has a signature
$(\sigma_1\times\cdots\times\sigma_n)\to\sigma$.  Function~$\nu$ is always
applied to $n$~terms whose sorts must be, respectively,
$\sigma_1$,~$\sigma_2$, \dots,~$\sigma_n$, and the resulting term has
sort~$\sigma$. We say that $\nu$~has \emph{arity}~$n$. \emph{Constants} are
functions with arity~$0$.

Typically, in mathematical logic, the set~$S$ of sorts and the function
signatures are required to satisfy further constraints. \textit{Bool} must
be one of the sorts. \emph{Formulas} are terms with sort \textit{Bool}.
The argument sorts ($\sigma_1$,~$\sigma_2$, \dots,~$\sigma_n$) either are
all \textit{Bool}, or none is \textit{Bool}.  If the argument sorts are
\textit{Bool}, then the result sort~$\sigma$ must also be \textit{Bool},
and $\nu$ is said to be a \emph{boolean connective}.  If the argument sorts
are not \textit{Bool} and the result sort~$\sigma$ is \textit{Bool}, then
$\nu$ is said to be a \emph{predicate}.  Agent~Factory has these
constraints and AF-Raf inherits them. In addition, AF-Raf uses an infix
notation (described later) for boolean connectives, letter strings starting
with uppercase for predicate names, and letter strings starting with
lowercase for other function names and for variable names.

\begin{remark}
\rg{I'm not sure about this remark. I think \emph{traditional} logicians
behave as described here.}
The definitions given here are in-between what applied computer scientists
tend to prefer and what pure logicians tend to prefer.  Computer scientists
work with \emph{expressions} (rather than terms and formulas) and do not
have constraints on function signatures with respect to booleans.
Logicians, on the other hand, do have these constraints and, moreover,
define terms in such a way that formulas are not terms, and predicates are
not functions. Moreover, logicians single out equality between terms as
being a special predicate.
\end{remark}

\rg{Maybe add some simple examples early on.}
In AF-Raf, a \emph{belief} is a boolean ground term; in AF-Raf, a
\emph{message} is a non-boolean ground term.

Algebraic data types offer an alternative way of defining sets of ground
terms. In multi-sorted predicate logic, the sort~$\sigma$ determines a set
of ground terms, namely those of the form $\nu(*)$, where $\nu$ has a
signature of the form $*\to\sigma$.  For example, the sort \textit{Bool}
determines the set of terms that are formulas.  With algebraic data types,
a type~$\delta$ is defined by a sequence of patterns, each of the form
$\nu(\delta_1,\ldots,\delta_n)$. For example, one could define the types
\textit{nat}, $e$, and~$o$ as follows.
\begin{align}
&\mathbf{type}\,\mathit{nat} =
      \mathit{zero}()
  \mid\mathit{succ}(\mathit{nat})
  \mid\mathit{add}(\mathit{nat},\mathit{nat}) \\
&\mathbf{type}\,e =
      \mathit{zero}()
  \mid\mathit{succ}(o)
  \mid\mathit{add}(e,e)
  \mid\mathit{add}(o,o) \\
&\mathbf{type}\,o =
      \mathit{succ}(e)
  \mid\mathit{add}(o,e)
  \mid\mathit{add}(e,o)
\end{align}
\rg{These things are presented as if they are completely standard. They're
not. I think they should be presented as part of the design of AF-RAF.}
We make the following observations.
\begin{enumerate}
\item
  Function names may appear in multiple definitions. For example,
  \textit{zero} appears in the definition of~$\mathit{nat}$ and also in the
  definition of~$e$. In particular, the term $\mathit{zero}()$ belongs both
  to the set of ground terms defined by the type~$\mathit{nat}$ and to the
  one defined by the type~$e$.
\item
  Function names may appear multiple times in the same definition. For
  example, \textit{add} appears twice in the definition of~$e$. (This
  property distinguishes our types from polymorphic
  variants~\cite{garrigue1998}.)
\item
  Type definitions may be recursive or mutually recursive. For example,
  $\mathit{nat}$~appears within the definition of~$\mathit{nat}$.
\end{enumerate}
The set of ground terms corresponding to type~$\mathit{nat}$ is the following.
\begin{equation}
\begin{aligned}
\{\,&\mathit{zero}(), \\
    &\mathit{succ}(\mathit{zero}()),
        \mathit{succ}(\mathit{succ}(\mathit{zero}())), \ldots \\
    &\mathit{add}(\mathit{zero}(), \mathit{zero}()),
        \mathit{add}(\mathit{zero}(), \mathit{succ}(\mathit{zero}())),
        \ldots \\
    &\mathit{succ}(\mathit{add}(\mathit{zero}(), \mathit{zero}())),
        \ldots \\
    &\ldots\, \}
\end{aligned}
\end{equation}
Moreover, $e$~and~$o$ partition~$\mathit{nat}$.

\begin{proposition}
Algebraic data types (as defined above) are strictly more expressive than
sorts. More precisely, (1)~all sets of ground terms that can be defined by
sorts can also be defined by algebraic data types, and (2)~there are pairs
of sets of ground terms that can be defined by algebraic data types but
cannot be defined by sorts.
\end{proposition}

\begin{proof}
For~(1), we define a type~$\delta(\sigma)$ for each sort~$\sigma$ as
follows: For each signature $\nu:(\sigma_1,\ldots,\sigma_n)\to\sigma$ we
add a pattern $\nu(\delta(\sigma_1),\ldots,\delta(\sigma_n))$. It is easy
to see, by structural induction, that the sort~$\sigma$ and the
type~$\delta(\sigma)$ define the same sets of ground terms.

For~(2), note that, given a fixed set of function signatures, the sets of
ground terms defined by distinct sorts are disjoint. In the previous
example, however, the sets of ground terms defined by the types
$\mathit{nat}$~and~$e$ have (at least) a common element, namely
$\mathit{zero}()$.
\end{proof}

Finally, let us note that there are sets of ground terms for which it is
undecidable whether a given term is an element.  (A classic result of
computability theory is that there are undecidable sets of bit-strings, and
sorted ground terms can encode bit-strings.) In particular, there exist
sets of ground terms that cannot be defined using algebraic data types.
\rg{These things are probably too cryptic, and should be explained more.}

\subsection{Haskell Type Classes}

This section reviews Haskell type classes, because they later inspire our
notion of `role', and Haskell modules, so that it is clear they are very
different from type classes. We use sets and equality as examples because
we assume all readers are familiar with these basic mathematical concepts.
\rg{Well, in a thesis you can afford the space to explain even basic concepts.}

% modules
%  - small example
%  - information hiding and encapsulation
%    (exact impl may change; but it is ONE)
%  - separate compilation
%  - analogy with Java classes

Haskell modules are often used to implement abstract data types such as
sets.  To illustrate the main features of modules in little space, the code
in Figure~\ref{fig:haskell} is contrived.  The module \textit{Set} contains
the type~$T$ and the functions \textit{add}, \textit{has}, and
\textit{sub}. The \textbf{module} line hides \textit{sub} by not mentioning
it. The names and types of the exported functions \textit{add} and
\textit{has} are visible from outside the module, but their
implementations, which are to the right of~$=$, are hidden.  Similarly, the
type name~$T$ is visible from outside, but the value constructor~$V$ is
not. For example, the set $\{1,2\}$ may be represented by the value
$V[2,1,2]$, but this is not known to the users of the module \textit{Set}.
The names and types visible from outside constitute the module's
\emph{interface}.

\begin{figure}\footnotesize % <<<
\begin{verbatim}
-- built-in and standard library
class Eq b where
  eq :: b -> b -> Bool
instance Eq Int where ...
elem x [] = False
elem x (y:ys) = eq x y || elem x ys
all p [] = True
all p (x:xs) = p x && all p xs

-- file set.hs
module Set (T, add, has) where
  data T a = V [a]
  add (V s) x = V (x:s)
  has (V s) x = elem x s
  sub (V s) t = all (has t) s

  instance Eq a => Eq (T a) where
    eq s t = sub s t && sub t s
\end{verbatim}
\caption{Haskell type class \textit{Eq} and module \textit{Set}}
\label{fig:haskell}
\end{figure} % >>>

% type classes
%  - continue example
%  - ad-hoc polymorphism: multiple implementations with the same interface
%  - analogy with Java interfaces

The type class \textit{Eq} contains types whose values can be compared for
equality. To make a type belong to the class \textit{Eq} one must write an
instance declaration that provides an implementation for a function
named~$eq$. The \textbf{instance} declaration in module \textit{Set} says
that the type constructor~$T$ transforms members of \textit{Eq} into
members of \textit{Eq}. For example, $T(T\,\mathit{Int})$ is in \textit{Eq}
because \textit{Int} is in~\textit{Eq}.

In general, modules are responsible with information
hiding~\cite{DBLP:journals/cacm/Parnas72a} and encapsulation.  On the other
hand, type classes are an elegant mechanism to provide ad-hoc polymorphism,
also known as overloading~\cite{DBLP:conf/popl/WadlerB89}: The same name
refers to different implementations depending on the context.  Just as
Haskell type classes are different from Haskell modules, the roles we
introduce later are different from existing 2APL
modules~\cite{dblp:conf/prima/dastanims08}.

\subsection{Session Types}

\section{Literature Review}

MD Travers, 1996, Programming with agents: xenia.media.mit.edu/~mt/thesis/mt-thesis-Contents.html

% >>>

\end{document}
% >>>
% vim:fmr=<<<,>>>:tw=75:spell:fo+=t:
