%{{{ latex prelude
\documentclass{article}
\usepackage{xcolor}

\def\fb#1{\textbf{#1}}

\newcommand{\todo}[1]{[\textcolor{red}{TODO}: #1]}

\title{Roles in Agent Oriented Programming\\\normalsize{a survey}}
\author{Claudia Grigore, Rem Collier, Radu Grigore}
% latex prelude }}}

\begin{document}
\maketitle

% {{{ abstract
\begin{abstract}
\end{abstract}
% abstract }}}
%{{{ introduction
\section{Introduction}
% AOP = SE imports concepts from sociology
% these concepts are higher level than in OOP
% roles are even higher level concepts that structure interaction
% they are somewhat similar to dynamic traits


AOP (\fb agent \fb oriented \fb programming) researchers look for inspiration in sociology when they attack software engineering problems.
At first, this may seem a forced marriage.
After all, software engineering studies computer programs written by programs, while sociology studies self-organizing human societies; there are thousands of computer programs and comparatively few distinct human societies; computer programs are large collections of simple instructions that interact in complex ways, while human societies are made of people, which interact in complex ways; software engineers not only study programs but also build them.
In short, it is so easy to find differences that it may be hard to see what software engineering and sociology have in common.
At a very abstract level, software engineering and sociology share an interest in understanding complex systems.
However, this similarity is too abstract to be of much use.
After all, \emph{all} sciences are concerned to some degree with taming complexity, but 
So there must be a more specific way that describes the similarity between software engineering and sociology.


Sociology and software engineering might not seem much related at first.
One studies human societies; the other studies computer programs.
But there are also similarities.
Both societies and programs are complex entities with many interacting parts.
There are, of course, differences.
Human societies are usually self-organizing, while programs are designed and built by programmers.
Sociologists study a few human societies, while software engineers build and analyze thousands of programs.
Sociologists developed concepts and theories that make it easy to understand human societies.


is a research area whose goal is
to find better ways to design and develop programs by using concepts imported
from sociology. AOP methodologies, frameworks, and programming languages 

working in this area range from
programming languages to methodologies. The type of applications that benefit
the most from these results are those that are inherently distributed, an
example being, unsurprisingly, simulators of societies.

It is fairly clear now how certain social concepts,
such as belief and behaviour, apply to programming
(Section~\ref{sec:background}). Much recent work focuses
on the assimilation from sociology of the concepts
of role and organisation, which are closely related
(Section~\ref{sec:software_engineering}).
%}}} introduction
%{{{ background
\section{Background}
\label{sec:background}

Compared to OOP (\fb object \fb oriented programming), AOP (\fb
agent \fb oriented \fb programming) is done at a higher level of
abstraction. The state of an agent is a set of beliefs, which
are described in a logic-like language. The actions of the agent
are dictated by declarative rules. In AOP style, it is easy to
simulate societies and to code distributed algorithms.

\todo{Give an example in AgentFactory.}

\todo{Briefly explain concepts related to agents that are used later,
  \emph{except} roles and organisations. Use examples.}
\todo{Talk about FIPA specs.}
\todo{Talk about JADE.}
\todo{Talk about other AOP languages and frameworks that do \emph{not}
  have roles, but are referred to later, perhaps because they were
  extended with roles.}

The Java Agent DEvelopment framework complies with the FIPA
specifications and is implemented in Java. Several systems
including roles are built on top of it. \todo{Say exactly which
are those systems.}
%}}} background
%{{{ roles in sociology
\section{Roles in Sociology}

Roles are sets of connected behaviours, rights, and obligations
that correspond to the social position of a person (agent) in a
group (organisation). This definition is used both by functionalists
(for example, Auguste Comte) and by modern and contemporary
interactionists.
%}}} roles in sociology
%{{{ roles in software engineering
\section{Roles in Software Engineering}
\label{sec:software_engineering}

\todo{Explain the typical relation between agents, roles, and
  organisations.}
\todo{Explain the difference between a (conceptual) model and an
  implementation. Make it clear what is the difference between a
  model and a meta-model.}
AOP (agent oriented programming) is supported by languages and by
frameworks.  \todo{Explain the difference between languages and
frameworks.}


\todo{More intro.}

\todo{For the following, make it clear which are conceptual models and
  which are implementations.}
\todo{Decide when you say `multi-agent system' and when `agent system'.
  It's probably OK to stick to just one.}

\subsection{AGENT0}
\subsection{AFAPL2}
\subsection{PLACA}
\subsection{SPLAW}
\subsection{SLABSp}
\subsection{Jason}
\subsection{3APL, 2APL}
\subsection{GOAL}
\subsection{MetateM}
\subsection{J-Moise+}
\subsection{Normative multi-agent programming language}

\subsection{AALAADIN} 
\label{sec:aalaadin}

AGR, AALAADIN's meta-model, is a model for organisation-centered
multi-agent systems. AGR is based on three main concepts: agents,
groups and roles.

An organisation is constituted of agents that manifest a behaviour.
The overall organisation can be partitioned into groups that may
overlap. 

Agents play roles within groups. A group can be viewed as a
context for activities. Two agents can interact only if they are
members of the same group, but usually an agent is member of
several groups. Groups are sets of agents that either have some
similar characteristics or work together toward a common goal.

A role describes an abstract behaviour of agents and represents the
abstraction of a functional position of an agent in a group.

\subsection{BRAIN} 

The BRAIN Framework supports the development of interactions
in agent-based applications, using the concept of role. It
consists of (1)~an interaction model, (2)~an XML-based notation
to express roles (XRole), and (3)~an interaction infrastructure
implementation (Rolesystem).

A role is a set of capabilities and has an expected behaviour.
Capabilities are activities that an agent can perform. Behaviours
are reactions to incoming events. \todo{What is a `reaction'?
Does a role have one or multiple behaviours? Does a behaviour
prescribe one action for one event or multiple actions for a
combination of events?}

Rolesystem is built on top of Jade. It translates actions of
agents into event notifications to other agents. An event may,
in turn, trigger actions, according to the roles assumed by
the notified agent. In this way, Rolesystem, facilitates the
interaction between agents.

\subsection{Jade extension}

\todo{Does this have a better name than `Jade extension'?}

\todo{This paragraph seems to serve as a good general description
of the relation between agents, roles, and organizations.}
Baldoni et al. extended the Jade framework to offer primitives
for constructing organisations. The underlying conceptual model
is based on the concept of role. Roles are used to structure the
organisation, to distribute responsibilities among agents and as
a means of coordination. A role exists only in the context of an
organisation, working as an interface between the organisation and
agents. Roles offer powers to the agents to operate inside the
organisation, and in the same time request a set of requirements
from them. The expected behaviour is described in terms of goals and
beliefs attributed to a role. An agent can play multiple roles in an
organisation but not simultaneously, only one role at a time can be
active. \todo{addDROPS} \todo{Explain the previous TODO.}

\subsection{JadeOrgs}

JadeOrgs extends Jade. Unlike a Jade agent, a JadeOrgs
agent manages roles and organisation membership. A JadeOrgs
organisation is a Jade agent that manages a group of JadeOrg
agents. \todo{`Manages' sounds a bit like `leads', when what I
mean is that it bookkeeps membership. Rephrase.} Roles consist
of (1)~required behaviours, (2)~required ontologies, and
(3)~templates for messages. \todo{Huh? Why would a role have
templates for messages? Explain.}

\subsection{Moise+} 

The Moise+ organisational model is the first one to join roles
with plans. It consists of three main dimensions: structural,
functional and deontic. Roles represent the structural, plans
are the functional, and the relations between roles and
plans represent the deontic dimension. \todo{Define the word
`deontic'.}

\todo{Decide on some shape for the following three paragraphs
and use the same shape for all three.}

The structural dimension has three levels. The individual level
is represented by roles, which are viewed as sets of constraints
that agents ought to follow. The social level is represented
by links, which are relations between roles, and constrain the
agents' behaviour in relation to other agents. The collective
level is represented by groups, which introduce compatibility
constraints between roles, which specify what roles an agent is
allowed to assume, depending on the roles that it is currently
playing. \todo{Perhaps this paragraph could be made to flow
better.}

The functional dimension is based on the concepts of missions
(sets of coherent goals that an agent can commit to), global
plans (goals in a structure) and social scheme (the goal
decomposition tree). 

The deontic dimension defines at the individual level the set of
obligations and permissions of a role on a mission.

Saci-Moise+, Jason-Moise+ and Moise+JavaAPI frameworks are all
implementations of the Moise+ meta-model. \todo{More detail.}

\subsection{MadKit} 

MadKit is a multi-agent platform written in Java. It is build upon
the AGR organisational model (Section~\ref{sec:aalaadin}).

MadKit supports heterogeneity in agent architectures and
communication languages. Agents can be programmed in Java,
Scheme, Jess and BeanShell.

\subsection{GAIA}
\subsection{MaSE}
\subsection{OMNI}
\subsection{SODA}
\subsection{Styx}
\subsection{Tropos}
%}}} roles in software engineering
%{{{ conclusion
\section{Conclusion}
%}}} conclusion

\bibliographystyle{plain}
\bibliography{survey}

\end{document}
