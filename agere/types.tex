\documentclass[preprint]{sigplanconf} % <<<
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}

\lstset{columns=fullflexible}
\lstset{identifierstyle=\itshape,commentstyle=\rm}
\lstset{literate={->}{{$\to\;$}}1 {<-}{{$\gets\;$}}1 {=>}{{$\Rightarrow\;$}}1}
\lstdefinestyle{hs}{language=haskell,deletekeywords={elem,all,Eq,Num,Int}}
\lstdefinestyle{me}{language=haskell,keywords={role,agent,plays,true,this,PG,R,rules,send,session,repeat}}

\title{Type-checking in Agent Oriented Programming}
\authorinfo
  {Claudia Grigore and Rem W.~Collier}
  {University College Dublin}
  {claudia.grigore@ucdconnect.ie}

\begin{document} % <<<
\maketitle
\begin{abstract} % <<<
There is virtually no type-checking in Agent Oriented Programming at the
moment. Type errors can lead to erroneous calculations. We propose typing
beliefs and message content using abstract data types. We present a type-checking implementation.

\end{abstract} % >>>
\category{I.2.11}{Artificial Intelligence}{Distributed Artificial
Intelligence}[Multiagent Systems]
\terms Languages
\keywords Types, Messages, Beliefs

\section{Introduction} % <<<
The intuition that a function is like a pair of messages, one carrying the
arguments and one carrying the result, led us to two interesting
observations. First, algebraic data types are convenient for describing the
content of messages. We expect to see fewer runtime errors once messages
are typed. Second, we developed a notion of role in the context of the 2APL
language. These roles have certain similarities with existing 2APL modules
and with Java interfaces, but are nevertheless distinct concepts.

We want types~\cite{DBLP:conf/ctcs/Hagino87}.

% >>>
\section{Agent Factory} %<<<
Agent Factory~\cite{collier2002agent} is an open-source Java-based
development framework that provides support for the development and
deployment of agent-oriented applications.

Agent Factory (AF) provides a generic run-time environment for deploying
agent-based systems that is based on the FIPA standards~\cite{poslad2000fipa}.
Central to this environment is a configurable agent platform that supports the
concurrent deployment of heterogeneous agent types employing a range of agent
architectures and interpreters. AF also supports the deployment of
platform-level resources in the form of platform services that are shared
amongst agents, along with monitoring and inspection tools that aid the
developer in debugging their implementations. 

The Common Language Framework (CLF) is a collection of components that
facilitates the design and implementation of diverse Agent Programming
Languages in AF. CLF includes a generic logic framework, a planning and
plan execution framework, a common API model based on sensors, actions and
modules, an outline Grammar and template compiler implementation based on
JavaCC, and a configurable debugging tool.

Currently there are four Agent Programming Languages that have been built
using the CLF: AFAPL, a reimplementation of the original Agent Factory
agent programming language that is based on commitment rules,
AF-AgentSpeak, an implementation of the AgentSpeak language based on
Jason, AF-TeleoReactive, an implementation of Nilsson's teleo-reactive
programming model, and AF-Raf, described in the next section.

Agent Factory is fully integrated with Eclipse in a way that simplifies
the task of providing support for new languages and architectures.

For further details on the current incarnation of Agent Factory the reader
is directed to~\cite{collier2009modeling}. Also, a discussion on the
evolution of Agent Factory since its inception in the early 1990s can be
found in~\cite{muldoon2009towards}.

% >>>
\section{Overview} % <<<

In AgentFactory, beliefs and messages are logic terms. A \emph{term} is a
variable or a function applied to other terms.
\begin{align}
\mathit{Term}\quad\tau
  &::= \omega
  \mid \phi(\tau_1,\ldots,\tau_n) \\
\mathit{Variable}\quad\omega
  &::= x, y, z, \ldots \\
\mathit{Function}\quad\phi
  &::= f, g, h, \ldots
\end{align}
During development, it often happens that agents fail with run-time errors
caused by terms not having the expected form. For example, an agent might
expect to receive a message with a constant integer, but gets a string.  (A
\emph{constant} is a function of arity~$0$.) Often the bug is in the code
that constructed the message, rather than in the code that parses the
message and fails at run-time. In order to get better diagnostic support
during development, we added sorts to the AgentFactory framework.

Agents should be autonomous, so they should not crash. Instead, illegal
operations (such as division by~$0$) should be caught and turned into
beliefs that allow the agent to subsequently adjust. However, this is true
for a release build. During development we want to ensure that the agent
will seldom need to take exceptional corrective measures. Hence, during
development we \emph{do} want agents to fail close to the buggy code.

Traditionally, in a multi-sorted logic each term has a sort~$\sigma$ and
each function symbol~$\phi$ has a \emph{signature}
$\sigma_1\times\cdots\times\sigma_n\to\sigma$: The term it constructs has
sort~$\sigma$, and the $k$th argument must be a term of sort~$\sigma_k$. We
opt, however, for a more flexible approach. We define a \emph{sort} to be a
set of terms.

% >>>
% ending <<<
\acks

The authors thank the Irish Research Council for Science, Engineering and
Technology for funding.

\bibliographystyle{abbrvnat}
\bibliography{types}

% >>>
\end{document} % >>>

% vim:tw=75:fmr=<<<,>>>:fo+=t:nosi:
