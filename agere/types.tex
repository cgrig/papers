\documentclass[preprint]{sigplanconf} % <<<
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[british]{babel}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage[colorlinks]{hyperref}

\newcommand{\B}{\mathbb{B}}

\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{\sectionautorefname}

%\theoremstyle{definition}
%\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
%\newtheorem{notation}{Notation}

\definecolor{darkblue}{rgb}{0,0,0.4}
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}

\lstset{columns=fullflexible}
\lstset{identifierstyle=\itshape,commentstyle=\rm}
\lstset{literate={->}{{$\to\;$}}1 {<-}{{$\gets\;$}}1 {=>}{{$\Rightarrow\;$}}1}
\lstdefinestyle{hs}{language=haskell,deletekeywords={elem,all,Eq,Num,Int}}
\lstdefinestyle{me}{language=haskell,keywords={role,agent,plays,true,this,PG,R,rules,send,session,repeat}}

\title{
  AF-Raf: An Agent-Oriented Programming Language with Algebraic Data Types}
\authorinfo
  {Claudia Grigore and Rem W.~Collier}
  {University College Dublin}
  {claudia.grigore@ucdconnect.ie}

% >>>
\begin{document} % <<<
\maketitle
\begin{abstract} % <<<
There is virtually no type-checking in Agent Oriented Programming at the
moment. Type errors can lead to erroneous calculations. We propose typing
beliefs and message content using abstract data types. We present a type-checking implementation.

\end{abstract} % >>>
\category{I.2.11}{Artificial Intelligence}{Distributed Artificial
Intelligence}[Multiagent Systems]
\terms Languages
\keywords Types, Messages, Beliefs

\section{Introduction} % <<<

In previous work~\cite{grigore2011}, we argue for incorporating ideas from
functional programming into agent-oriented programming. Specifically, we
argue (1)~for importing algebraic data types, (2)~for making roles similar
to type classes, and (3)~for orchestrating global interactions using
session types. In this article we explain how algebraic data types fit in
an agent-oriented programming language. Using the Agent~Factory
framework~\cite{russell2011af} (\autoref{sec:af}), we developed a
programming language called AF-Raf that has beliefs, (behaviour) rules,
(FIPA~\cite{poslad2000fipa}) messages, and algebraic data
types~(\autoref{sec:af-raf} and \autoref{sec:af-raf.types}).

The state of an agent is a belief base, and agents communicate through
messages. Both beliefs and messages are typically formulas in some
predicate logic. Our proposal to add algebraic data types to the
programming language is essentially equivalent to using a
\emph{multi-sorted} predicate logic for beliefs and for
messages~(\autoref{sec:multi-sorted}). The main benefit is that bugs are
easier to identify, both by developers and by agents~(\autoref{sec:bugs}).

In Agent~Factory, agents written in different languages may interact
through messages. Hence, agents that use multi-sorted logic may interact
with agents that use unsorted logic~(\autoref{sec:unsorted}).

Our main contribution is AF-Raf, a simple agent-oriented programming
language that has algebraic data types~\cite{site:af-raf}.

% >>>
\section{The Agent Factory Framework} \label{sec:af} % <<<

Agent Factory~\cite{collier2002agent} is an open-source Java-based
development framework that provides support for the development and
deployment of agent-oriented applications.

Agent Factory (AF) provides a generic run-time environment for deploying
agent-based systems that is based on the FIPA standards~\cite{poslad2000fipa}.
Central to this environment is a configurable agent platform that supports the
concurrent deployment of heterogeneous agent types employing a range of agent
architectures and interpreters. AF also supports the deployment of
platform-level resources in the form of platform services that are shared
amongst agents, along with monitoring and inspection tools that aid the
developer in debugging their implementations. 

The Common Language Framework (CLF) is a collection of components that
facilitates the design and implementation of diverse Agent Programming
Languages in AF. CLF includes a generic logic framework, a planning and
plan execution framework, a common API model based on sensors, actions and
modules, an outline Grammar and template compiler implementation based on
JavaCC, and a configurable debugging tool.

Currently there are four Agent Programming Languages that have been built
using the CLF: 
\begin{enumerate}

\item \textit{AFAPL}, a reimplementation of the original Agent Factory
agent programming language that is based on commitment rules;

\item \textit{AF-AgentSpeak}, an implementation of the AgentSpeak language based on Jason;

\item \textit{AF-TeleoReactive}, an implementation of Nilsson's teleo-reactive
programming model; 

\item and our new \textit{AF-Raf}, described in the next section.
\end{enumerate}

Agent Factory is fully integrated with Eclipse in a way that simplifies
the task of providing support for new languages and architectures.

For further details on Agent Factory the reader is directed
to~\cite{collier2009modeling}. The Common Language Framework is described
in~\cite{russell2011af}. Also, a discussion on the evolution of Agent Factory since it
was created in the early 1990s can be found in~\cite{muldoon2009towards}.

% >>>
\section{AF-Raf without Types} \label{sec:af-raf} % <<<

AF-Raf is a new programming language we created to incorporate
type-checking. The AF-Raf agent has two fundamental components a
\textit{belief base} (to model the agent's view of the current state of its
environment) and a \textit{rule base} (to model the agent's behaviour).

Beliefs are terms, where a term denotes an expression that can be obtained
from either a constant symbol, a variable or a function symbol. Rules are
represented by a name (optional), a query and an action.  The code in
Figure~\ref{fig:AF-Raf} illustrates an AF-Raf agent.


\begin{figure}\footnotesize % <<<
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=hs]

include stdio

rule State(initialized()) & Name(n) {
    println("hello from " + n);
}
  
rule Monitoring(name, addr) {
    println("ask " + name + " for status");
    send(agentID(name, addr), request(status()));
}

rule Message(inform(), agentID(name, addr()), status(alive())) {
    println("OK, ask again.");
    send(agentID(name, addr), request(status())); 
}
    
rule Message(request(), sender, status()) {
    println("Oh, someone wants me alive!");
    send(sender, inform(status(alive())));
}


\end{lstlisting}
\end{tabular}
\end{center}
\caption{a monitoring AF-Raf agent}
\label{fig:AF-Raf}
\end{figure} % >>>

The rules are evaluated at each time-step. The first stage of evaluating a
rule is to evaluate the query on the current belief base. The result is a
set of query results. If the set is not empty, the action is then evaluated
for every query result. A particular query result says with what term to
substitute each free variable in the action. In other words, a query result
is a set of bindings that covers all the free variable in the action (of
the rule). The first step of evaluating the action is to apply these
substitutions. The next step is to execute it. 

An action is either a simple action or a composed action. Executing a
simple action means executing a piece of associated Java code. Examples of
simple actions include sending a message (\textit{send}), logging a string
(\textit{println}), and adopting a belief (\textit{adopt}).  Composed
actions, also referred to as plans, include sequence and while loops.

Sensors are pieces of Java code that are run at each time-step. They are
used to update the belief base according to the changes in the environment.
An example of a sensor is the \textit{RafStandardSensor}.

% >>>
\section{Multi-Sorted Predicate Logic} \label{sec:multi-sorted} % <<<

In this section we recall basic notions from mathematical logic that are
necessary to understand the next section. We also introduce notational
conventions used in AF-Raf.

A \emph{term} is a variable or a function applied to other terms.
\begin{align}
\mathit{Term}\quad\tau &::= \omega \mid \phi \\
\mathit{Variable}\quad\omega &::= \nu \\
\mathit{Function}\quad\phi &::= \nu(\tau_1,\ldots,\tau_n) \\
\mathit{Name}\quad\nu
\end{align}
In AF-Raf, term names are strings.  Because term names uniquely identify a
variable or a function we will say ``the function~$\nu$'' rather than ``the
function with name~$\nu$.'' A term not containing variables is said to be
\emph{ground}.

\begin{remark}
Ground terms are essentially trees of strings.
\end{remark}

A multi-sorted logic has a set~$S$ of sorts.  We use the letter~$\sigma$ to
denote sorts.
\begin{align}
\sigma, \sigma_1, \sigma_2, \sigma_3, \ldots &\in S
\end{align}
Each function~$\nu$ has a signature
$(\sigma_1\times\cdots\times\sigma_n)\to\sigma$.  Function~$\nu$ is always
applied to $n$~terms whose sorts must be, respectively,
$\sigma_1$,~$\sigma_2$, \dots,~$\sigma_n$, and the resulting term has
sort~$\sigma$. We say that $\nu$~has \emph{arity}~$n$. \emph{Constants} are
functions with arity~$0$.

Typically, in mathematical logic, the set~$S$ of sorts and the function
signatures are required to satisfy further constraints. The set~$\B$ of
booleans must be one of the sorts. \emph{Formulas} are terms with
sort~$\B$.  The argument sorts ($\sigma_1$,~$\sigma_2$, \dots,~$\sigma_n$)
either are all~$\B$, or none is~$\B$. If the argument sorts are~$\B$, then
the result sort~$\sigma$ must also be~$\B$, and $\nu$ is said to be a
\emph{boolean connective}. If the argument sorts are not~$\B$ and the
result sort~$\sigma$ is~$\B$, then $\nu$ is said to be a \emph{predicate}.
Agent~Factory has these constraints and AF-Raf inherits them. In addition,
AF-Raf uses an infix notation (described later) for boolean connectives,
letter strings starting with uppercase for predicate names, and letter
strings starting with lowercase for other function names.

\begin{remark}
The definitions given here are in-between what applied computer scientists
tend to prefer and what pure logicians tend to prefer.  Computer scientists
work with \emph{expressions} and do not have constraints on function
signatures with respect to booleans. Logicians, on the other hand, do have
these constraints and, moreover, define terms in such a way that formulas
are not terms, and predicates are not functions.
\end{remark}

In AF-Raf, a \emph{belief base} is a set of boolean ground terms.

% >>>
\section{AF-Raf with Types} \label{sec:af-raf.types} % <<<

% >>>
\section{Debugging and Autonomy} \label{sec:bugs} % <<<

% >>>
\section{Interactions with Other Languages} \label{sec:unsorted} % <<<

% >>>
\section{Related Work} \label{sec:related} % <<<

% >>>
\section{Conclusions} \label{sec:conclusions} % <<<

% >>>
\section{To Move} % <<<

In Agent~Factory, beliefs and messages are logic terms. A \emph{term} is a
variable or a function applied to other terms.
\begin{align}
\mathit{Term}\quad\tau
  &::= \omega
  \mid \phi(\tau_1,\ldots,\tau_n) \\
\mathit{Variable}\quad\omega
  &::= x, y, z, \ldots \\
\mathit{Function}\quad\phi
  &::= f, g, h, \ldots
\end{align}
During development, it often happens that agents fail with run-time errors
caused by terms not having the expected form. For example, an agent might
expect to receive a message with a constant integer, but gets a string.  (A
\emph{constant} is a function of arity~$0$.) Often the bug is in the code
that constructed the message, rather than in the code that parses the
message and fails at run-time. In order to get better diagnostic support
during development, we added sorts to the Agent~Factory framework.

Agents should be autonomous, so they should not crash. Instead, illegal
operations (such as division by~$0$) should be caught and turned into
beliefs that allow the agent to subsequently adjust. However, this is true
for a release build. During development we want to ensure that the agent
will seldom need to take exceptional corrective measures. Hence, during
development we \emph{do} want agents to fail close to the buggy code.

Traditionally, in a multi-sorted logic each term has a sort~$\sigma$ and
each function symbol~$\phi$ has a \emph{signature}
$\sigma_1\times\cdots\times\sigma_n\to\sigma$: The term it constructs has
sort~$\sigma$, and the $k$th argument must be a term of sort~$\sigma_k$. We
opt, however, for a more flexible approach. We define a \emph{sort} to be a
set of terms.

% >>>
% ending <<<
\acks

The authors thank the Irish Research Council for Science, Engineering and
Technology for funding.

\bibliographystyle{abbrvnat}
\bibliography{types}

% >>>
\end{document} % >>>

% vim:tw=75:fmr=<<<,>>>:fo+=t:nosi:spl=en_gb:
