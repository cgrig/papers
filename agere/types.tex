\documentclass[preprint]{sigplanconf} % <<<
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\todo}[1]{{\small \textcolor{gray}{[\textcolor{red}{TODO}: #1]}}}
\newenvironment{notes}{\medskip\hrule\nobreak\smallskip\narrower}{\smallskip\hrule\medskip}

\lstset{columns=fullflexible}
\lstset{identifierstyle=\itshape,commentstyle=\rm}
\lstset{literate={->}{{$\to\;$}}1 {<-}{{$\gets\;$}}1 {=>}{{$\Rightarrow\;$}}1}
\lstdefinestyle{hs}{language=haskell,deletekeywords={elem,all,Eq,Num,Int}}
\lstdefinestyle{me}{language=haskell,keywords={role,agent,plays,true,this,PG,R,rules,send,session,repeat}}

\title{Type-checking in Agent Oriented Programming}
\authorinfo
  {Claudia Grigore and Rem W.~Collier}
  {University College Dublin}
  {claudia.grigore@ucdconnect.ie}

\begin{document} % <<<
\maketitle
\begin{abstract} % <<<
There is virtually no type-checking in Agent Oriented Programming at the
moment. Type errors can lead to erroneous calculations. We propose typing
beliefs and message content using abstract data types. We present a type-checking implementation.

\end{abstract} % >>>
\category{I.2.11}{Artificial Intelligence}{Distributed Artificial
Intelligence}[Multiagent Systems]
\terms Languages
\keywords Types, Messages, Beliefs

\section{Introduction} % <<<
The intuition that a function is like a pair of messages, one carrying the
arguments and one carrying the result, led us to two interesting
observations. First, algebraic data types are convenient for describing the
content of messages. We expect to see fewer runtime errors once messages
are typed. Second, we developed a notion of role in the context of the 2APL
language. These roles have certain similarities with existing 2APL modules
and with Java interfaces, but are nevertheless distinct concepts.

We want types~\cite{DBLP:conf/ctcs/Hagino87}.

% >>>
\section{Agent Factory framework and AF-Raf programming language} %<<<
\subsection{Agent Factory}
Agent Factory~\cite{collier2002agent} is an open-source Java-based
development framework that provides support for the development and
deployment of agent-oriented applications.

Agent Factory (AF) provides a generic run-time environment for deploying
agent-based systems that is based on the FIPA standards~\cite{poslad2000fipa}.
Central to this environment is a configurable agent platform that supports the
concurrent deployment of heterogeneous agent types employing a range of agent
architectures and interpreters. AF also supports the deployment of
platform-level resources in the form of platform services that are shared
amongst agents, along with monitoring and inspection tools that aid the
developer in debugging their implementations. 

The Common Language Framework (CLF) is a collection of components that
facilitates the design and implementation of diverse Agent Programming
Languages in AF. CLF includes a generic logic framework, a planning and
plan execution framework, a common API model based on sensors, actions and
modules, an outline Grammar and template compiler implementation based on
JavaCC, and a configurable debugging tool.

Currently there are four Agent Programming Languages that have been built
using the CLF: 
\begin{enumerate}

\item \textit{AFAPL}, a reimplementation of the original Agent Factory
agent programming language that is based on commitment rules;

\item \textit{AF-AgentSpeak}, an implementation of the AgentSpeak language based on Jason;

\item \textit{AF-TeleoReactive}, an implementation of Nilsson's teleo-reactive
programming model; 

\item and our new \textit{AF-Raf}, described in the next section.
\end{enumerate}

Agent Factory is fully integrated with Eclipse in a way that simplifies
the task of providing support for new languages and architectures.

For further details on Agent Factory the reader is directed
to~\cite{collier2009modeling}. The Common Language Framework is described
in~\cite{russell2011af}. Also, a discussion on the evolution of Agent Factory since it
was created in the early 1990s can be found in~\cite{muldoon2009towards}.

\subsection{AF-Raf}
AF-Raf is a new programming language we created to incorporate
type-checking. The AF-Raf agent has two fundamental components a
\textit{belief base} (to model the agent's view of the current state of its
environment) and a \textit{rule base} (to model the agent's behaviour).

Beliefs are terms, where a term denotes an expression that can be obtained
from either a constant symbol, a variable or a function symbol. Rules are
represented by a name (optional), a query and an action.  The code in
Figure~\ref{fig:AF-Raf} illustrates an AF-Raf agent.


\begin{figure}\footnotesize % <<<
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=hs]

include stdio

rule State(initialized()) & Name(n) {
    println("hello from " + n);
}
  
rule Monitoring(name, addr) {
    println("ask " + name + " for status");
    send(agentID(name, addr), request(status()));
}

rule Message(inform(), agentID(name, addr()), status(alive())) {
    println("OK, ask again.");
    send(agentID(name, addr), request(status())); 
}
    
rule Message(request(), sender, status()) {
    println("Oh, someone wants me alive!");
    send(sender, inform(status(alive())));
}


\end{lstlisting}
\end{tabular}
\end{center}
\caption{a monitoring AF-Raf agent}
\label{fig:AF-Raf}
\end{figure} % >>>

The rules are evaluated at each time-step. The first stage of evaluating a
rule is to evaluate the query on the current belief base. The result is a
set of query results. If the set is not empty, the action is then evaluated
for every query result. A particular query result says with what term to
substitute each free variable in the action. In other words, a query result
is a set of bindings that covers all the free variable in the action (of
the rule). The first step of evaluating the action is to apply these
substitutions. The next step is to execute it. 

An action is either a simple action or a composed action. Executing a
simple action means executing a piece of associated Java code. Examples of
simple actions include sending a message (\textit{send}), logging a string
(\textit{println}), and adopting a belief (\textit{adopt}).  Composed
actions, also referred to as plans, include sequence and while loops.

Sensors are pieces of Java code that are run at each time-step. They are
used to update the belief base according to the changes in the environment.
An example of a sensor is the \textit{RafStandardSensor}.

% >>>
\section{Overview} % <<<

In AgentFactory, beliefs and messages are logic terms. A \emph{term} is a
variable or a function applied to other terms.
\begin{align}
\mathit{Term}\quad\tau
  &::= \omega
  \mid \phi(\tau_1,\ldots,\tau_n) \\
\mathit{Variable}\quad\omega
  &::= x, y, z, \ldots \\
\mathit{Function}\quad\phi
  &::= f, g, h, \ldots
\end{align}
During development, it often happens that agents fail with run-time errors
caused by terms not having the expected form. For example, an agent might
expect to receive a message with a constant integer, but gets a string.  (A
\emph{constant} is a function of arity~$0$.) Often the bug is in the code
that constructed the message, rather than in the code that parses the
message and fails at run-time. In order to get better diagnostic support
during development, we added sorts to the AgentFactory framework.

Agents should be autonomous, so they should not crash. Instead, illegal
operations (such as division by~$0$) should be caught and turned into
beliefs that allow the agent to subsequently adjust. However, this is true
for a release build. During development we want to ensure that the agent
will seldom need to take exceptional corrective measures. Hence, during
development we \emph{do} want agents to fail close to the buggy code.

Traditionally, in a multi-sorted logic each term has a sort~$\sigma$ and
each function symbol~$\phi$ has a \emph{signature}
$\sigma_1\times\cdots\times\sigma_n\to\sigma$: The term it constructs has
sort~$\sigma$, and the $k$th argument must be a term of sort~$\sigma_k$. We
opt, however, for a more flexible approach. We define a \emph{sort} to be a
set of terms.

% >>>
% ending <<<
\acks

The authors thank the Irish Research Council for Science, Engineering and
Technology for funding.

\bibliographystyle{abbrvnat}
\bibliography{types}

% >>>
\end{document} % >>>

% vim:tw=75:fmr=<<<,>>>:fo+=t:nosi:
